<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minima</title>
    <link rel="icon" type="image/x-icon" href="minima.ico">
    <style>
        :root {
            --bg-color: #121212;
            --card-bg: #1e1e1e;
            --text-main: #e0e0e0;
            --accent: #485BAB;
            --accent-hover: #5a6fc4;
            --error: #ff5252;
            --border: #333;
            --warning: #ffa726;
        }

        <style>
            :root {
                --bg-color: #121212;
                --card-bg: #1e1e1e;
                --text-main: #e0e0e0;
                --accent: #485BAB;
                --accent-hover: #5a6fc4;
                --error: #ff5252;
                --border: #333;
                --warning: #ffa726;
            }

            html {
                background-color: var(--bg-color);
            }

            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                color: var(--text-main);
                display: flex;
                flex-direction: column;
                align-items: center;
                padding: 20px;
                margin: 0;
                min-height: 100vh;
            }

            body::before {
                content: "";
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-image: url('background.png');
                background-size: cover;
                background-position: center;
                background-attachment: fixed;
                opacity: 0.05;
                z-index: -1;
            }

        .container {
            width: 100%;
            max-width: 500px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: var(--accent);
            margin-bottom: 5px;
        }

        /* Language Dropdown in Corner */
        .language-selector {
            position: fixed;
            top: 15px;
            right: 15px;
            z-index: 1000;
        }

        .language-selector select {
            padding: 6px 10px;
            background: rgba(30, 30, 30, 0.9);
            border: 1px solid var(--border);
            color: var(--text-main);
            border-radius: 6px;
            font-size: 0.85em;
            cursor: pointer;
            appearance: auto;
            min-width: 80px;
            backdrop-filter: blur(10px);
        }

        .language-selector select:hover {
            border-color: var(--accent);
        }

        .language-selector select:focus {
            outline: none;
            border-color: var(--accent);
        }

        @media (max-width: 600px) {
            .language-selector {
                top: 10px;
                right: 10px;
            }
        }

        .info-box {
            background: #2c2c2c;
            padding: 15px;
            border-radius: 8px;
            font-size: 0.9em;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
        }

        .card {
            background: var(--card-bg);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 1px solid var(--border);
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            font-size: 0.85em;
            text-transform: uppercase;
            color: #888;
        }

        select {
            width: 100%;
            padding: 12px;
            margin-bottom: 20px;
            background: #252525;
            border: 1px solid var(--border);
            color: white;
            border-radius: 6px;
            appearance: none;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .input-group select {
            margin-bottom: 0;
            flex-grow: 1;
        }

        .magic-btn {
            display: none;
            align-items: center;
            justify-content: center;
            width: 46px;
            height: 46px;
            background: #2c2c2c;
            border: 1px solid var(--accent);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            padding: 0;
            overflow: hidden;
            color: white;
        }

        .magic-icon {
            width: 24px;
            height: 24px;
            object-fit: contain;
            pointer-events: none;
        }

        .magic-btn:hover {
            background: var(--accent);
            border-color: white;
        }

        .magic-btn.loading {
            animation: spin 1s linear infinite;
            cursor: wait;
            opacity: 0.5;
        }

        @keyframes spin { 
            100% { transform: rotate(360deg); } 
        }

        button.main-btn {
            width: 100%;
            padding: 15px;
            background: var(--accent);
            color: black;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        button.main-btn:disabled {
            background: #444;
            color: #888;
            cursor: not-allowed;
        }

        .result {
            margin-top: 25px;
            padding: 20px;
            border-radius: 8px;
            display: none;
        }

        .result.show { display: block; }
        .red { border: 2px solid var(--error); background: rgba(255, 82, 82, 0.1); }
        .green { border: 2px solid var(--accent); background: rgba(0, 230, 118, 0.1); }
        .neutral { border: 2px solid #555; background: #222; }
        .warning { border: 2px solid var(--warning); background: rgba(255, 167, 38, 0.1); }

        .visibility-box {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(72, 91, 171, 0.15);
            border: 2px solid var(--accent);
            border-radius: 8px;
        }

        .visibility-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .visibility-label {
            font-size: 0.8em;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .visibility-value {
            font-size: 1.3em;
            font-weight: bold;
            color: white;
        }

        .wind-components {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
            padding: 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            border: 1px solid #333;
        }

        .wind-item {
            display: flex;
            flex-direction: column;
        }

        .wind-label {
            font-size: 0.75em;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 3px;
        }

        .wind-value {
            font-size: 1.0em;
            font-weight: bold;
        }

        .headwind { color: #4CAF50; }
        .tailwind { color: #ff5252; }
        .crosswind { color: #ffa726; }

        pre {
            background: #000;
            padding: 10px;
            color: #0f0;
            font-size: 0.8em;
            overflow-x: auto;
            border-radius: 4px;
        }

        footer {
            margin-top: 40px;
            padding: 20px;
            text-align: center;
            font-size: 0.8em;
            color: #888;
            border-top: 1px solid var(--border);
            width: 100%;
        }

        footer a {
            color: var(--accent);
            text-decoration: none;
        }

        .container {
            width: 100%;
            max-width: 500px;
            position: relative;
        }

        .image-box {
            width: 100%;
            margin-top: 20px;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid var(--border);
            background: var(--card-bg);
            line-height: 0;
        }

        .image-box img {
            width: 100%;
            height: auto;
            display: block;
        }
    </style>
</head>
<body>
    <!-- Language Dropdown in Corner -->
    <div class="language-selector">
        <select id="langSelect">
            <option value="en">English</option>
            <option value="no">Norsk</option>
        </select>
    </div>

    <div class="container">
        <div class="header">
            <h1 style="color:#FFFFFF;" data-i18n="title">Minima</h1>
            <p style="margin:0; color:#888;">Fly aware, Fly safe  ┋  89 Aerodromes</p>
        </div>

        <div class="info-box">
            <strong>How it works:</strong><br>Check the status of any supported approach. We'll reference it to <strong>current weather conditions</strong> and your <strong>aircraft's capabilities</strong> to let you know if it's safe to fly.<br><br>Put in an aerodrome, runway and aircraft, then press the wand - we'll <strong>recommend</strong> the approach we think best suited.
        </div>

        <div class="card">
            <label data-i18n="selectAirport">Aerodrome</label>
            <select id="airport">
                <option value="">Select Airport</option>
            </select>

            <label data-i18n="selectAircraft">Aircraft</label>
            <select id="aircraft">
                <option value="">Select Aircraft</option>
            </select>

            <label data-i18n="selectRunway">Runway</label>
            <select id="runway" disabled>
                <option value="">Select Airport First</option>
            </select>

            <div class="input-group">
                <div style="flex-grow: 1;">
                    <label data-i18n="selectApproach">Approach</label>
                    <select id="approach" disabled>
                        <option value="">Select Runway First</option>
                    </select>
                </div>
                <div style="align-self: flex-end;">
                    <button class="magic-btn" id="magicWand" title="Recommend best approach">
                        <svg class="magic-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <path d="M15 4V2M15 16v-2M8 9h2M20 9h2M17.8 11.8L19 13M17.8 6.2L19 5M3 21l9-9M12.2 6.2L11 5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </button>
                </div>
            </div>

            <button class="main-btn" id="checkBtn" disabled data-i18n="checkMinima">Check Minima</button>

            <div class="result" id="result"></div>
        </div>
    </div>
    <div class="image-box">
            <img src="box.png" alt="Box Decoration">
        </div>
    </div>
    <footer>
        <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ee9e87808b8f9e9e828b8d9c8f94978f98ae89838f8782c08d8183">[email&#160;protected]</a>
    </footer>

    <footer>
        <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="02726b6c676372726e67617063787b637442656f636b6e2c616d6f">[email&#160;protected]</a>
    </footer>

    <!-- Load airport data from external file -->
    <script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script src="airports-data.js"></script>

    <script>
        // ============================================
        // TRANSLATIONS
        // ============================================
        
        const translations = {
            en: {
                title: "Minima",
                selectAirport: "Select Airport",
                selectRunway: "Select Runway",
                selectAircraft: "Select Aircraft",
                selectApproach: "Select Approach",
                checkMinima: "Check Minima",
                required: "Required",
                actual: "Actual",
                headwind: "Headwind",
                tailwind: "Tailwind",
                crosswind: "Crosswind",
                windFrom: "Wind From",
                windSpeed: "Wind Speed",
                gusting: "Gusting",
                currentMetar: "Current METAR",
                metarStatus: "METAR Status",
                aboveMinima: "GO FOR IT!",
                belowMinima: "BELOW MINIMA",
                metarUnavailable: "METAR UNAVAILABLE",
                noWeatherData: "⚠️ No weather data",
                noWeatherMessage: "No METAR available - recommended approach has lowest visibility requirement",
                noCurrentWeather: "No current weather data is available for this aerodrome. You can still proceed with your flight planning, but verify actual weather conditions through other sources.",
                windVariable: "⚠️ Wind is variable - component calculations unavailable",
                errorRecommending: "Error recommending approach",
                airports: {
                    EGLL: "London Heathrow",
                    EGKK: "London Gatwick",
                    EHAM: "Amsterdam Schiphol",
                    EDDF: "Frankfurt",
                    EDDM: "Munich",
                    LFPG: "Paris Charles de Gaulle",
                    LEMD: "Madrid Barajas",
                    LIRF: "Rome Fiumicino",
                    LPPT: "Lisbon",
                    ESSA: "Stockholm Arlanda",
                    ENGM: "Oslo Gardermoen",
                    ENBR: "Bergen Flesland",
                    ENZV: "Stavanger Sola",
                    ENTC: "Tromsø",
                    ENVA: "Trondheim Værnes",
                }
            },
            no: {
                title: "Minima",
                selectAirport: "Velg flyplass",
                selectRunway: "Velg rullebane",
                selectAircraft: "Velg fly",
                selectApproach: "Velg innflyging",
                checkMinima: "Sjekk minima",
                required: "Påkrevd",
                actual: "Faktisk",
                headwind: "Motvind",
                tailwind: "Medvind",
                crosswind: "Sidevind",
                windFrom: "Vind fra",
                windSpeed: "Vindhastighet",
                gusting: "Kast til",
                currentMetar: "Gjeldende METAR",
                metarStatus: "METAR-status",
                aboveMinima: "KLART FOR LANDING!",
                belowMinima: "UNDER MINIMA",
                metarUnavailable: "METAR IKKE TILGJENGELIG",
                noWeatherData: "⚠️ Ingen værdata",
                noWeatherMessage: "Ingen METAR tilgjengelig - anbefalt innflyging har laveste siktekrav",
                noCurrentWeather: "Ingen værdata er tilgjengelig for denne flyplassen. Du kan fortsette med flightplanleggingen, men verifiser faktiske værforhold gjennom andre kilder.",
                windVariable: "⚠️ Vinden er variabel - komponentberegninger ikke tilgjengelig",
                errorRecommending: "Feil ved anbefaling av innflyging",
                airports: {
                    EGLL: "London Heathrow",
                    EGKK: "London Gatwick",
                    EHAM: "Amsterdam Schiphol",
                    EDDF: "Frankfurt",
                    EDDM: "München",
                    LFPG: "Paris Charles de Gaulle",
                    LEMD: "Madrid Barajas",
                    LIRF: "Roma Fiumicino",
                    LPPT: "Lisboa",
                    ESSA: "Stockholm Arlanda",
                    ENGM: "Oslo Gardermoen",
                    ENBR: "Bergen Flesland",
                    ENZV: "Stavanger Sola",
                    ENTC: "Tromsø",
                    ENVA: "Trondheim Værnes",
                }
            }
        };

        let currentLang = 'en';

        // ============================================
        // EMBEDDED DATA
        // ============================================
        
        // Aircraft categories mapping
        const AIRCRAFT_MAP = {
            "A20N": "c", "A21N": "c", "A319": "c", "A320": "c", "A321": "c",
            "A332": "d", "A333": "d", "A338": "d", "A339": "d", "A343": "d",
            "A346": "d", "A359": "d", "A35K": "d", "A388": "d", "AT76": "b",
            "B38M": "c", "B39M": "c", "B737": "c", "B738": "c", "B739": "c",
            "B763": "d", "B764": "d", "B77F": "d", "B77L": "d", "B77W": "d",
            "B772": "d", "B788": "d", "B789": "d", "B78X": "d", "C172": "a",
            "C25B": "c", "C750": "c", "DA40": "a", "DA42": "a", "DH8D": "b",
            "E190": "c", "E175": "c", "MD11": "d", "MD82": "c", "PA28": "a",
            "TBM8": "b", "E170": "c", "E195": "c", "E290": "c", "E295": "c",
            "B350": "b", "PC21": "b", "BSC1": "c", "BSC3": "c"
        };

        // Airport data is loaded from airports-data.js

        // ============================================
        // UTILITY FUNCTIONS
        // ============================================

        function parseWindData(metar) {
            if (!metar) return { direction: null, speed: null, gust: null };
            
            const windPattern = /(\d{3}|VRB)(\d{2,3})(G(\d{2,3}))?KT/;
            const match = metar.match(windPattern);
            
            if (match) {
                const directionStr = match[1];
                const speed = parseInt(match[2]);
                const gust = match[4] ? parseInt(match[4]) : null;
                
                if (directionStr === "VRB") {
                    return { direction: null, speed, gust };
                }
                
                return { 
                    direction: parseInt(directionStr), 
                    speed, 
                    gust 
                };
            }
            
            return { direction: null, speed: null, gust: null };
        }

        function calculateWindComponents(windSpeed, windFromDirection, runwayHeading) {
            if (windFromDirection === null || windSpeed === null) {
                return { headwind: null, crosswind: null };
            }
            
            const angleDiff = windFromDirection - runwayHeading;
            const angleRad = (angleDiff * Math.PI) / 180;

            const headwind = windSpeed * Math.cos(angleRad);
            const crosswind = windSpeed * Math.sin(angleRad);
            
            return { headwind, crosswind };
        }

        function getRunwayHeading(runway) {
            const match = runway.match(/(\d{2})/);
            if (match) {
                return parseInt(match[1]) * 10;
            }
            return null;
        }

        function getVisibility(metar, runway) {
            if (!metar) return "N/A";

            if (metar.includes("CAVOK")) {
                return "9999";
            }

            // RVR (e.g. R27R/0600)
            const rw = runway.padStart(2, '0');
            const rvrPattern = new RegExp(`R${rw}[LCR]?/(\\d{4})`);
            const rvrMatch = metar.match(rvrPattern);
            if (rvrMatch) {
                return rvrMatch[1];
            }

            // Statute miles (e.g. 3SM)
            const smMatch = metar.match(/(\d+)SM/);
            if (smMatch) {
                return String(parseInt(smMatch[1]) * 1609);
            }

            // Plain visibility (e.g. 4000)
            const visMatch = metar.match(/\b(\d{4})\b/);
            if (visMatch) {
                return visMatch[1];
            }

            return "N/A";
        }

        async function fetchMETAR(icao) {
            const url = `https://metar.vatsim.net/${icao}`;
            try {
                const response = await fetch(url);
                if (response.ok) {
                    const metarText = await response.text();
                    if (metarText && metarText.trim() && !metarText.startsWith("No METAR")) {
                        return metarText;
                    }
                }
            } catch (error) {
                console.error('METAR fetch error:', error);
            }
            return null;
        }

        function loadAirportData(airport) {
            return AIRPORT_DATA[airport.toLowerCase()] || null;
        }

        // ============================================
        // CORE LOGIC
        // ============================================

        function calculateMinima(airport, runway, aircraft, approach) {
            airport = airport.toLowerCase();
            aircraft = aircraft.toUpperCase();

            const data = loadAirportData(airport);
            if (!data) return { error: "Unknown airport" };
            
            if (!AIRCRAFT_MAP[aircraft]) return { error: "Unknown aircraft" };

            const category = AIRCRAFT_MAP[aircraft];

            // Reconstruct the JSON key
            let key;
            if (approach.startsWith("rnp-")) {
                const suffix = approach.split("-")[1];
                key = suffix === "approach" ? `rnp${runway}` : `rnp${runway}-${suffix}`;
            } else {
                key = `${approach}${runway}`;
            }

            if (!data[key] || !data[key][category]) {
                return { error: `Minima not defined for ${key} (Cat ${category})` };
            }

            const val = data[key][category];
            const required = String(val).match(/^\d+$/) ? parseInt(val) : 0;

            return {
                airport: airport.toUpperCase(),
                runway,
                required,
                key,
                category
            };
        }

        async function checkMinimaWithWeather(airport, runway, aircraft, approach) {
            const minimaData = calculateMinima(airport, runway, aircraft, approach);
            
            if (minimaData.error) {
                return minimaData;
            }

            const metar = await fetchMETAR(airport.toUpperCase());
            
            if (metar === null) {
                return {
                    ...minimaData,
                    visibility: "N/A",
                    status: "METAR UNAVAILABLE",
                    metar: "No METAR data available for this aerodrome",
                    wind: null
                };
            }

            const visibility = getVisibility(metar, runway);
            const windParsed = parseWindData(metar);
            const runwayHeading = getRunwayHeading(runway);
            
            let windData = null;
            if (windParsed.direction !== null && windParsed.speed !== null && runwayHeading !== null) {
                const { headwind, crosswind } = calculateWindComponents(
                    windParsed.speed, 
                    windParsed.direction, 
                    runwayHeading
                );
                
                windData = {
                    direction: windParsed.direction,
                    speed: windParsed.speed,
                    gust: windParsed.gust,
                    headwind: Math.round(headwind * 10) / 10,
                    crosswind: Math.round(crosswind * 10) / 10,
                    variable: false
                };
            } else if (windParsed.speed !== null) {
                windData = {
                    direction: "VRB",
                    speed: windParsed.speed,
                    gust: windParsed.gust,
                    headwind: null,
                    crosswind: null,
                    variable: true
                };
            }

            let status;
            if (minimaData.required === 0) {
                status = "UNAVAILABLE";
            } else {
                status = "ABOVE MINIMA";
                if (visibility.match(/^\d+$/) && parseInt(visibility) < minimaData.required) {
                    status = "BELOW MINIMA";
                }
            }

            return {
                ...minimaData,
                visibility,
                status,
                metar,
                wind: windData
            };
        }

        async function recommendApproach(airport, runway, aircraft) {
            airport = airport.toLowerCase();
            runway = runway.toUpperCase();
            aircraft = aircraft.toUpperCase();

            const data = loadAirportData(airport);
            if (!data) return { error: "Unknown airport" };

            if (!AIRCRAFT_MAP[aircraft]) return { error: "Unknown aircraft" };

            const category = AIRCRAFT_MAP[aircraft];

            const ilsGls = [];
            const others = [];

            // Collect approaches
            for (const key in data) {
                console.log('Checking key:', key);
                if (!data[key][category]) continue;

                // RNP approaches
                const rnpMatch = key.match(new RegExp(`^rnp${runway}(?:-(.+))?$`));
                if (rnpMatch) {
                    const suffix = rnpMatch[1] || "approach";
                    others.push(`rnp-${suffix.toLowerCase()}`);
                    continue;
                }

                // ILS / GLS
                if ((key.startsWith("il") || key.startsWith("gl")) && key.endsWith(runway)) {
                    const prefix = key.slice(0, -runway.length);
                    ilsGls.push(prefix);
                } else if (key.endsWith(runway)) {
                    const prefix = key.slice(0, -runway.length);
                    others.push(prefix);
                }
            }

            if (ilsGls.length === 0 && others.length === 0) {
                return { error: "No approaches available for this runway" };
            }

            // Test if METAR is available
            const testPrefix = ilsGls.length > 0 ? ilsGls[0] : others[0];
            const testResult = await checkMinimaWithWeather(airport, runway, aircraft, testPrefix);
            
            const metarUnavailable = testResult.status === "METAR UNAVAILABLE";

            // If METAR unavailable, recommend lowest requirement
            if (metarUnavailable) {
                const allApproaches = [];
                
                const catRank = (prefix) => {
                    if (prefix.startsWith("il")) return parseInt(prefix[2]);
                    if (prefix.startsWith("gl")) return parseInt(prefix[3]);
                    return 999;
                };
                
                for (const prefix of ilsGls) {
                    const result = calculateMinima(airport, runway, aircraft, prefix);
                    if (result.required > 0) {
                        allApproaches.push([catRank(prefix), result.required, prefix]);
                    }
                }
                
                for (const prefix of others) {
                    const result = calculateMinima(airport, runway, aircraft, prefix);
                    if (result.required > 0) {
                        allApproaches.push([999, result.required, prefix]);
                    }
                }
                
                if (allApproaches.length > 0) {
                    allApproaches.sort((a, b) => a[0] - b[0] || a[1] - b[1]);
                    return {
                        recommended: allApproaches[0][2],
                        metar_unavailable: true,
                        message: "No METAR available - recommended approach has lowest visibility requirement"
                    };
                }
                
                return { error: "No approaches available with defined minima" };
            }

            // ILS / GLS logic (CAT I → CAT III)
            if (ilsGls.length > 0) {
                const catRank = (p) => {
                    if (p.startsWith("il")) return parseInt(p[2]);
                    if (p.startsWith("gl")) return parseInt(p[3]);
                    return 9;
                };

                ilsGls.sort((a, b) => catRank(a) - catRank(b));

                for (const prefix of ilsGls) {
                    const result = await checkMinimaWithWeather(airport, runway, aircraft, prefix);
                    if (result.status === "ABOVE MINIMA") {
                        return { recommended: prefix };
                    }
                }
            }

            // No ILS/GLS → lowest RVR requirement wins
            const candidates = [];

            for (const prefix of others) {
                const result = await checkMinimaWithWeather(airport, runway, aircraft, prefix);
                
                if (result.status !== "ABOVE MINIMA") continue;
                if (!result.required || result.required <= 0) continue;
                
                candidates.push([result.required, prefix]);
            }

            if (candidates.length > 0) {
                candidates.sort((a, b) => a[0] - b[0]);
                return { recommended: candidates[0][1] };
            }

            return { error: "No suitable approach above minima" };
        }

        // ============================================
        // TRANSLATION FUNCTIONS
        // ============================================

        function translate() {
            const t = translations[currentLang];
            
            // Update all elements with data-i18n attribute
            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                if (t[key]) {
                    element.textContent = t[key];
                }
            });
            
            // Reload dropdowns to update airport names
            if (airportSel.options.length > 0) {
                loadAirports();
            }
            if (aircraftSel.options.length > 0) {
                loadAircraft();
            }
            
            // Update placeholder options
            updateDropdownPlaceholders();
        }

        function updateDropdownPlaceholders() {
            const t = translations[currentLang];
            if (airportSel.options[0]) airportSel.options[0].textContent = t.selectAirport;
            if (runwaySel.options[0]) runwaySel.options[0].textContent = t.selectRunway;
            if (aircraftSel.options[0]) aircraftSel.options[0].textContent = t.selectAircraft;
            if (approachSel.options[0]) approachSel.options[0].textContent = t.selectApproach;
        }

        function getTranslatedAirportName(code) {
            const t = translations[currentLang];
            if (t.airports[code]) {
                return t.airports[code];
            }
            // Fallback to data if not in translations
            if (AIRPORT_DATA[code] && AIRPORT_DATA[code].name) {
                return AIRPORT_DATA[code].name;
            }
            return "";
        }

        // ============================================
        // UI FUNCTIONS
        // ============================================

        const airportSel = document.getElementById('airport');
        const aircraftSel = document.getElementById('aircraft');
        const runwaySel = document.getElementById('runway');
        const approachSel = document.getElementById('approach');
        const checkBtn = document.getElementById('checkBtn');
        const magicWand = document.getElementById('magicWand');
        const resultDiv = document.getElementById('result');

        function loadAirports() {
            const t = translations[currentLang];
            const currentValue = airportSel.value;
            airportSel.innerHTML = `<option value="">${t.selectAirport}</option>`;
            const airports = Object.keys(AIRPORT_DATA).map(code => ({
                code: code.toUpperCase(),
                name: getTranslatedAirportName(code)
            }));
            airports.sort((a, b) => a.code.localeCompare(b.code));
            airports.forEach(ap => {
                const option = new Option(`${ap.code}${ap.name ? ' - ' + ap.name : ''}`, ap.code);
                airportSel.add(option);
            });
            airportSel.value = currentValue;
        }

        function loadAircraft() {
            const t = translations[currentLang];
            const currentValue = aircraftSel.value;
            aircraftSel.innerHTML = `<option value="">${t.selectAircraft}</option>`;
            const aircraft = Object.keys(AIRCRAFT_MAP).sort();
            aircraft.forEach(ac => aircraftSel.add(new Option(ac, ac)));
            aircraftSel.value = currentValue;
        }

        function loadRunways() {
            approachSel.innerHTML = '<option value="">Select Approach</option>';
            approachSel.disabled = true;
            runwaySel.value = "";
            runwaySel.disabled = true;
            runwaySel.innerHTML = '<option value="">Loading...</option>';
            
            if (!airportSel.value) return;

            const data = loadAirportData(airportSel.value);
            if (!data) {
                runwaySel.innerHTML = '<option value="">No data</option>';
                return;
            }

            const runways = new Set();

            for (const key in data) {
                const match = key.match(/(\d{2}[LRC]?)(?:-[a-z0-9]+)?$/);
                if (match) {
                    runways.add(match[1]);
                }
            }

            runwaySel.innerHTML = '<option value="">Select Runway</option>';
            Array.from(runways).sort().forEach(rw => runwaySel.add(new Option(rw, rw)));
            runwaySel.disabled = false;
            updateUI();
        }

        function loadApproaches() {
            if (!aircraftSel.value) {
                approachSel.innerHTML = '<option value="">Select Aircraft First</option>';
                return;
            }

            approachSel.disabled = true;
            approachSel.innerHTML = '<option value="">Loading...</option>';

            const airport = airportSel.value.toLowerCase();
            const runway = runwaySel.value.toUpperCase();
            const aircraft = aircraftSel.value.toUpperCase();

            const data = loadAirportData(airport);
            if (!data || !runway) {
                approachSel.innerHTML = '<option value="">No data</option>';
                return;
            }

            const category = AIRCRAFT_MAP[aircraft];
            const approaches = [];

            for (const key in data) {
                const minima = data[key];

                // RNP approaches
                const rnpMatch = key.match(new RegExp(`^rnp${runway}(?:-(.+))?$`));
                if (rnpMatch) {
                    const suffix = rnpMatch[1] || "approach";
                    approaches.push({
                        type: "RNP",
                        label: `RNP ${suffix.toUpperCase()}`,
                        value: `rnp-${suffix.toLowerCase()}`,
                        required: category ? minima[category] : null
                    });
                    continue;
                }

                // ILS / GLS / others
                const match = key.match(/^([a-z]{2,4}[123]?)(\d{2}[LRC]?)$/);
                if (!match || match[2] !== runway) continue;

                const prefix = match[1];
                let label, type;

                if (prefix.startsWith("il")) {
                    label = `ILS CAT ${prefix[2]}`;
                    type = "ILS";
                } else if (prefix.startsWith("gl")) {
                    label = `GLS CAT ${prefix[prefix.length - 1]}`;
                    type = "GLS";
                } else if (prefix.toLowerCase().startsWith("crc")) {
                    label = "CIRCLING";
                    type = "CIRCLING";
                } else if (prefix.toLowerCase().startsWith("vis")) {
                    label = "VISUAL";
                    type = "VISUAL";
                } else {
                    label = prefix.toUpperCase();
                    type = label;
                }

                approaches.push({
                    type,
                    label,
                    value: prefix,
                    required: category ? minima[category] : null
                });
            }

            approachSel.innerHTML = '<option value="">Select Approach</option>';
            approaches.forEach(ap => approachSel.add(new Option(ap.label, ap.value)));

            approachSel.disabled = false;
            updateUI();
        }

        function updateUI() {
            const allSelected = airportSel.value && runwaySel.value && aircraftSel.value && approachSel.value;
            checkBtn.disabled = !allSelected;

            const canRecommend = airportSel.value && runwaySel.value && aircraftSel.value && approachSel.options.length > 1;
            magicWand.style.display = canRecommend ? "flex" : "none";
        }

        async function onRecommendApproach() {
            const t = translations[currentLang];
            if (magicWand.classList.contains("loading")) return;

            magicWand.classList.add("loading");

            try {
                const data = await recommendApproach(
                    airportSel.value,
                    runwaySel.value,
                    aircraftSel.value
                );

                if (data.recommended) {
                    approachSel.value = data.recommended;
                    updateUI();
                    
                    if (data.metar_unavailable) {
                        resultDiv.className = "result show warning";
                        resultDiv.innerHTML = `
                            <p style="font-size: 1.1em; margin-top:0;"><strong>${t.noWeatherData}</strong></p>
                            <p style="margin: 10px 0;">${data.message || t.noWeatherMessage}</p>
                        `;
                    }
                } else if (data.error) {
                    alert("Error: " + data.error);
                }
            } catch (e) {
                console.error(e);
                alert(t.errorRecommending);
            } finally {
                magicWand.classList.remove("loading");
            }
        }

        function formatWindComponents(wind) {
            const t = translations[currentLang];
            if (!wind) return '';
            
            if (wind.variable) {
                let windText = `<div class="wind-components">
                    <div class="wind-item">
                        <span class="wind-label">${t.windSpeed}</span>
                        <span class="wind-value">VRB ${wind.speed}kt</span>
                    </div>`;
                
                if (wind.gust) {
                    windText += `
                    <div class="wind-item">
                        <span class="wind-label">${t.gusting}</span>
                        <span class="wind-value">${wind.gust}kt</span>
                    </div>`;
                }
                
                windText += `</div>
                    <p style="font-size: 0.85em; color: #ffa726; margin: 10px 0;">${t.windVariable}</p>`;
                return windText;
            }
            
            let html = '<div class="wind-components">';
            
            // Headwind/Tailwind
            const hw = wind.headwind;
            if (hw >= 0) {
                html += `
                    <div class="wind-item">
                        <span class="wind-label">${t.headwind}</span>
                        <span class="wind-value headwind">${Math.abs(hw).toFixed(1)}kt</span>
                    </div>`;
            } else {
                html += `
                    <div class="wind-item">
                        <span class="wind-label">${t.tailwind}</span>
                        <span class="wind-value tailwind">${Math.abs(hw).toFixed(1)}kt</span>
                    </div>`;
            }
            
            // Crosswind
            const xw = wind.crosswind;
            const xwDir = xw > 0 ? 'Right' : xw < 0 ? 'Left' : '';
            html += `
                <div class="wind-item">
                    <span class="wind-label">${t.crosswind} ${xwDir}</span>
                    <span class="wind-value crosswind">${Math.abs(xw).toFixed(1)}kt</span>
                </div>`;
            
            // Wind direction and speed
            html += `
                <div class="wind-item">
                    <span class="wind-label">${t.windFrom}</span>
                    <span class="wind-value">${wind.direction}°</span>
                </div>`;
            
            html += `
                <div class="wind-item">
                    <span class="wind-label">${t.windSpeed}</span>
                    <span class="wind-value">${wind.speed}kt</span>
                </div>`;
            
            html += '</div>';
            
            if (wind.gust) {
                html += `<p style="font-size: 0.85em; color: #ffa726; margin: 10px 0;">${t.gusting} ${wind.gust}kt</p>`;
            }
            
            return html;
        }

        async function onCheckMinima() {
            const t = translations[currentLang];
            resultDiv.innerHTML = "Fetching weather...";
            resultDiv.className = "result show neutral";

            const data = await checkMinimaWithWeather(
                airportSel.value,
                runwaySel.value,
                aircraftSel.value,
                approachSel.value
            );

            if (data.error) {
                resultDiv.innerHTML = `<p style="color:var(--error)">${data.error}</p>`;
                return;
            }

            let colorClass = "neutral";
            if (data.status.includes("BELOW")) colorClass = "red";
            if (data.status.includes("ABOVE")) colorClass = "green";
            if (data.status === "UNAVAILABLE") colorClass = "neutral";
            if (data.status === "METAR UNAVAILABLE") colorClass = "warning";

            resultDiv.className = `result show ${colorClass}`;
            
            if (data.status === "METAR UNAVAILABLE") {
                resultDiv.innerHTML = `
                    <p style="font-size: 1.2em; margin-top:0;"><strong>${t.metarUnavailable}</strong></p>
                    <p style="margin: 10px 0;">${t.noCurrentWeather}</p>
                    <div style="margin-top: 15px;">
                        <span>${t.required}: <strong>${data.required}m</strong></span>
                    </div>
                    <label style="margin-top: 15px;">${t.metarStatus}</label>
                    <pre>${data.metar}</pre>
                `;
            } else {
                const displayStatus = data.status === "ABOVE MINIMA" ? t.aboveMinima : t.belowMinima;
                
                resultDiv.innerHTML = `
                    <p style="font-size: 1.2em; margin-top:0;"><strong>${displayStatus}</strong></p>
                    <div class="visibility-box">
                        <div class="visibility-item">
                            <span class="visibility-label">${t.required}</span>
                            <span class="visibility-value">${data.required}m</span>
                        </div>
                        <div class="visibility-item">
                            <span class="visibility-label">${t.actual}</span>
                            <span class="visibility-value">${data.visibility}m</span>
                        </div>
                    </div>
                    ${formatWindComponents(data.wind)}
                    <label>${t.currentMetar}</label>
                    <pre>${data.metar}</pre>
                `;
            }
        }

        // Event listeners
        airportSel.addEventListener('change', loadRunways);
        runwaySel.addEventListener('change', loadApproaches);
        aircraftSel.addEventListener('change', () => {
            if (r            if (runwaySel.value) loadApproaches();
        });
        approachSel.addEventListener('change', updateUI);
        checkBtn.addEventListener('click', onCheckMinima);
        magicWand.addEventListener('click', onRecommendApproach);

        // Language dropdown event listener
        document.getElementById('langSelect').addEventListener('change', function() {
            currentLang = this.value;
            translate();
            localStorage.setItem('language', currentLang);
        });

        // Load saved language preference and initialize
        window.addEventListener('DOMContentLoaded', () => {
            const savedLang = localStorage.getItem('language') || 'en';
            currentLang = savedLang;
            document.getElementById('langSelect').value = savedLang;
            
            loadAirports();
            loadAircraft();
            translate();
        });
    </script>
</body>
</html>
