<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minima</title>
    <link rel="icon" type="image/x-icon" href="minima.ico">
    <style>
            :root {
                --bg-color: #121212;
                --card-bg: #1e1e1e;
                --text-main: #e0e0e0;
                --accent: #485BAB;
                --accent-hover: #5a6fc4;
                --error: #ff5252;
                --border: #333;
                --warning: #ffa726;
            }

            html {
                background-color: var(--bg-color);
            }

            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                color: var(--text-main);
                display: flex;
                flex-direction: column;
                align-items: center;
                padding: 20px;
                margin: 0;
                min-height: 100vh;
            }

            body::before {
                content: "";
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-image: url('background.png');
                background-size: cover;
                background-position: center;
                background-attachment: fixed;
                opacity: 0.05;
                z-index: -1;
            }

        .container {
            width: 100%;
            max-width: 500px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: var(--accent);
            margin-bottom: 5px;
        }

        /* Language Dropdown in Corner */
        .language-selector {
            position: fixed;
            top: 15px;
            right: 15px;
            z-index: 1000;
        }

        .language-selector select {
            padding: 6px 10px;
            background: rgba(30, 30, 30, 0.9);
            border: 1px solid var(--border);
            color: var(--text-main);
            border-radius: 6px;
            font-size: 0.85em;
            cursor: pointer;
            appearance: auto;
            min-width: 80px;
            backdrop-filter: blur(10px);
        }

        .language-selector select:hover {
            border-color: var(--accent);
        }

        .language-selector select:focus {
            outline: none;
            border-color: var(--accent);
        }

        @media (max-width: 600px) {
            .language-selector {
                top: 10px;
                right: 10px;
            }
        }

        .info-box {
            background: #2c2c2c;
            padding: 15px;
            border-radius: 8px;
            font-size: 0.9em;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
        }

        .card {
            background: var(--card-bg);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 1px solid var(--border);
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            font-size: 0.85em;
            text-transform: uppercase;
            color: #888;
        }

        select {
            width: 100%;
            padding: 12px;
            margin-bottom: 20px;
            background: #252525;
            border: 1px solid var(--border);
            color: white;
            border-radius: 6px;
            appearance: none;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .input-group select {
            margin-bottom: 0;
            flex-grow: 1;
        }

        .magic-btn {
            display: none;
            align-items: center;
            justify-content: center;
            width: 46px;
            height: 46px;
            background: #2c2c2c;
            border: 1px solid var(--accent);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            padding: 0;
            overflow: hidden;
            color: white;
        }

        .magic-icon {
            width: 24px;
            height: 24px;
            object-fit: contain;
            pointer-events: none;
        }

        .magic-btn:hover {
            background: var(--accent);
            border-color: white;
        }

        .magic-btn.loading {
            animation: spin 1s linear infinite;
            cursor: wait;
            opacity: 0.5;
        }

        @keyframes spin { 
            100% { transform: rotate(360deg); } 
        }

        button.main-btn {
            width: 100%;
            padding: 15px;
            background: var(--accent);
            color: black;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        button.main-btn:disabled {
            background: #444;
            color: #888;
            cursor: not-allowed;
        }

        .result {
            margin-top: 25px;
            padding: 20px;
            border-radius: 8px;
            display: none;
        }

        .result.show { display: block; }
        .red { border: 2px solid var(--error); background: rgba(255, 82, 82, 0.1); }
        .green { border: 2px solid var(--accent); background: rgba(0, 230, 118, 0.1); }
        .neutral { border: 2px solid #555; background: #222; }
        .warning { border: 2px solid var(--warning); background: rgba(255, 167, 38, 0.1); }

        .visibility-box {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(72, 91, 171, 0.15);
            border: 2px solid var(--accent);
            border-radius: 8px;
        }

        .visibility-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .visibility-label {
            font-size: 0.8em;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .visibility-value {
            font-size: 1.3em;
            font-weight: bold;
            color: white;
        }

        .wind-components {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
            padding: 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            border: 1px solid #333;
        }

        .wind-item {
            display: flex;
            flex-direction: column;
        }

        .wind-label {
            font-size: 0.75em;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 3px;
        }

        .wind-value {
            font-size: 1.0em;
            font-weight: bold;
        }

        .headwind { color: #4CAF50; }
        .tailwind { color: #ff5252; }
        .crosswind { color: #ffa726; }

        pre {
            background: #000;
            padding: 10px;
            color: #0f0;
            font-size: 0.8em;
            overflow-x: auto;
            border-radius: 4px;
        }

        footer {
            margin-top: 40px;
            padding: 20px;
            text-align: center;
            font-size: 0.8em;
            color: #888;
            border-top: 1px solid var(--border);
            width: 100%;
        }

        footer a {
            color: var(--accent);
            text-decoration: none;
        }

        .container {
            width: 100%;
            max-width: 500px;
            position: relative;
        }

        .image-box {
            width: 100%;
            margin-top: 20px;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid var(--border);
            background: var(--card-bg);
            line-height: 0;
        }

        .image-box img {
            width: 100%;
            height: auto;
            display: block;
        }
    </style>
    <style>
    /* Discord Settings Menu Styles */
        .settings-icon {
            position: fixed;
            top: 15px;
            left: 15px;
            width: 40px;
            height: 40px;
            background: rgba(30, 30, 30, 0.9);
            border: 1px solid var(--border);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 1000;
        }

        .settings-icon:hover {
            background: var(--accent);
            border-color: white;
        }

        .settings-icon svg {
            width: 20px;
            height: 20px;
            fill: var(--text-main);
        }

        .settings-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .settings-modal.show {
            display: flex;
        }

        .settings-content {
            background: var(--card-bg);
            padding: 30px;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            border: 1px solid var(--border);
            max-height: 80vh;
            overflow-y: auto;
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .settings-header h2 {
            margin: 0;
            color: var(--accent);
        }

        .close-btn {
            background: none;
            border: none;
            color: var(--text-main);
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover {
            color: var(--accent);
        }

        .discord-section {
            margin-bottom: 25px;
            padding: 20px;
            background: #252525;
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .discord-status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--error);
        }

        .status-indicator.connected {
            background: #00ff00;
        }

        .discord-info {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
        }

        .discord-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid var(--accent);
        }

        .settings-btn {
            width: 100%;
            padding: 12px;
            margin-top: 10px;
            background: var(--accent);
            color: black;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .settings-btn:hover {
            opacity: 0.8;
        }

        .settings-btn.secondary {
            background: #444;
            color: white;
        }

        .settings-btn.danger {
            background: var(--error);
            color: white;
        }

        .notification-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: #2c2c2c;
            border-radius: 6px;
            margin-top: 15px;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background: #444;
            border-radius: 13px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: var(--accent);
        }

        .toggle-slider {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(24px);
        }
</style>
</head>
<body>
    <div class="language-selector">
        <select id="langSelect">
            <option value="en">EN</option>
            <option value="no">NO</option>
        </select>
    </div>

    <div class="container">
        <div class="header">
            <h1 style="color:#FFFFFF;" data-i18n="title">Minima</h1>
            <p style="margin:0; color:#888;">Fly aware, Fly safe  ┋  92 Aerodromes</p>
        </div>

        <div class="info-box">
            <strong data-i18n="howItWorksTitle">How it works:</strong><br>
            <span data-i18n="howItWorksDesc1">Check the status of any supported approach. We'll reference it to</span> 
            <strong data-i18n="currentWeatherConditions">current weather conditions</strong> 
            <span data-i18n="howItWorksDesc2">and your</span> 
            <strong data-i18n="aircraftCapabilities">aircraft's capabilities</strong> 
            <span data-i18n="howItWorksDesc3">to let you know if it's safe to fly.</span>
            <br><br>
            <span data-i18n="howItWorksDesc4">Put in an aerodrome, runway and aircraft, then press the wand - we'll</span> 
            <strong data-i18n="recommend">recommend</strong> 
            <span data-i18n="howItWorksDesc5">the approach we think best suited.</span>
        </div>
        <div class="card">
            <label data-i18n="selectAirport">Aerodrome</label>
            <select id="airport">
                <option value="">Select Airport</option>
            </select>

            <label data-i18n="selectAircraft">Aircraft</label>
            <select id="aircraft">
                <option value="">Select Aircraft</option>
            </select>

            <label data-i18n="selectRunway">Runway</label>
            <select id="runway" disabled>
                <option value="">Select Airport First</option>
            </select>

            <div class="input-group">
                <div style="flex-grow: 1;">
                    <label data-i18n="selectApproach">Approach</label>
                    <select id="approach" disabled>
                        <option value="">Select Runway First</option>
                    </select>
                </div>
                <div style="align-self: flex-end;">
                    <button class="magic-btn" id="magicWand" title="Recommend best approach">
                        <svg class="magic-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <path d="M15 4V2M15 16v-2M8 9h2M20 9h2M17.8 11.8L19 13M17.8 6.2L19 5M3 21l9-9M12.2 6.2L11 5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </button>
                </div>
            </div>

            <button class="main-btn" id="checkBtn" disabled data-i18n="checkMinima">Check Minima</button>

            <div class="result" id="result"></div>
        </div>
        <div class="image-box">
            <img src="box.png" alt="Box Decoration">
        </div>
    </div>
    <div class="settings-icon" onclick="openSettings()">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
        </svg>
    </div>
    <footer>
        pineapplecrazyav@gmail.com
    </footer>

    <script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script src="airports-data.js"></script>

    <script>
        // ============================================
        // TRANSLATIONS
        // ============================================
        
        const translations = {
            en: {
                title: "Minima",
                selectAirport: "Select Airport",
                selectRunway: "Select Runway",
                selectAircraft: "Select Aircraft",
                selectApproach: "Select Approach",
                checkMinima: "Check Minima",
                required: "Required",
                actual: "Actual",
                headwind: "Headwind",
                tailwind: "Tailwind",
                crosswind: "Crosswind",
                windFrom: "Wind From",
                windSpeed: "Wind Speed",
                gusting: "Gusting",
                howItWorksTitle: "How it works:",
                howItWorksDesc1: "Check the status of any supported approach. We'll reference it to",
                currentWeatherConditions: "current weather conditions",
                howItWorksDesc2: "and your",
                aircraftCapabilities: "aircraft's capabilities",
                howItWorksDesc3: "to let you know if it's safe to fly.",
                howItWorksDesc4: "Put in an aerodrome, runway and aircraft, then press the wand - we'll",
                recommend: "recommend",
                howItWorksDesc5: "the approach we think best suited.",
                currentMetar: "Current METAR",
                metarStatus: "METAR Status",
                aboveMinima: "GO FOR IT!",
                belowMinima: "BELOW MINIMA",
                metarUnavailable: "METAR UNAVAILABLE",
                noWeatherData: "⚠️ No weather data",
                noWeatherMessage: "No METAR available - recommended approach has lowest visibility requirement",
                noCurrentWeather: "No current weather data is available for this aerodrome. You can still proceed with your flight planning, but verify actual weather conditions through other sources.",
                windVariable: "⚠️ Wind is variable - component calculations unavailable",
                errorRecommending: "Error recommending approach",
                airports: {}
            },
            no: {
                title: "Minima",
                selectAirport: "Velg Flyplass",
                selectRunway: "Velg Rullebane",
                selectAircraft: "Velg Fly",
                selectApproach: "Velg Innflyging",
                checkMinima: "Sjekk Minima",
                required: "Påkrevd",
                actual: "Faktisk",
                headwind: "Motvind",
                tailwind: "Medvind",
                crosswind: "Sidevind",
                windFrom: "Vind fra",
                windSpeed: "Vindhastighet",
                gusting: "Vindkast",
                currentMetar: "Gjeldende METAR",
                metarStatus: "METAR-status",
                aboveMinima: "KLART FOR LANDING!",
                belowMinima: "UNDER MINIMA",
                metarUnavailable: "METAR IKKE TILGJENGELIG",
                noWeatherData: "⚠️ Ingen værdata",
                noWeatherMessage: "Ingen METAR tilgjengelig - anbefalt innflyging har laveste siktekrav",
                noCurrentWeather: "Ingen værdata er tilgjengelig for denne flyplassen. Du kan fortsette med flightplanleggingen, men verifiser faktiske værforhold gjennom andre kilder.",
                windVariable: "⚠️ Vinden er variabel - komponentberegninger ikke tilgjengelig",
                errorRecommending: "Feil ved anbefaling av innflyging",
                howItWorksTitle: "Slik fungerer det:",
                howItWorksDesc1: "Sjekk statusen til enhver støttet innflyging. Vi vil referere den til",
                currentWeatherConditions: "gjeldende værforhold",
                howItWorksDesc2: "og ditt",
                aircraftCapabilities: "flys kapasitet",
                howItWorksDesc3: "for å la deg vite om det er trygt å fly.",
                howItWorksDesc4: "Fyll inn en flyplass, rullebane og fly, deretter trykk på tryllestaven - vi vil",
                recommend: "anbefale",
                howItWorksDesc5: "innflygingen vi mener passer best.",
                airports: {
                    EBAW: "Antwerpen",
                    EBBR: "Brussel",
                    EBOS: "Oostende",
                    EDDK: "Køln-Bonn",
                    EDDN: "Nürnberg",
                    EDDV: "Hannover",
                    EFET: "Enontekis",
                    EFHK: "Helsingfors",
                    EFKI: "Kajana",
                    EFLP: "Villmanstrand",
                    EFMA: "Mariehamn / Åland",
                    EFOU: "Uleåborg",
                    EFTP: "Tammerfors",
                    EFTU: "Åbo",
                    EFVA: "Vasa",
                    EKCH: "København",
                    ELLX: "Luxemburg",
                    EPWA: "Warsawa",
                    ESGG: "Göteborg",
                    LKPR: "Praha",
                    LOWW: "Wien",
                    LSGG: "Genève",
                }
            }
        };

        let currentLang = 'en';
        
        // Aircraft categories mapping
        const AIRCRAFT_MAP = {
            "A20N": "c", "A21N": "c", "A319": "c", "A320": "c", "A321": "c",
            "A332": "d", "A333": "d", "A338": "d", "A339": "d", "A343": "d",
            "A346": "d", "A359": "d", "A35K": "d", "A388": "d", "AT76": "b",
            "B38M": "c", "B39M": "c", "B737": "c", "B738": "c", "B739": "c",
            "B763": "d", "B764": "d", "B77F": "d", "B77L": "d", "B77W": "d",
            "B772": "d", "B788": "d", "B789": "d", "B78X": "d", "C172": "a",
            "C25B": "c", "C750": "c", "DA40": "a", "DA42": "a", "DH8D": "b",
            "E190": "c", "E175": "c", "MD11": "d", "MD82": "c", "PA28": "a",
            "TBM8": "b", "E170": "c", "E195": "c", "E290": "c", "E295": "c",
            "B350": "b", "PC21": "b", "BSC1": "c", "BSC3": "c"
        };

        function parseWindData(metar) {
            if (!metar) return { direction: null, speed: null, gust: null };
            
            const windPattern = /(\d{3}|VRB)(\d{2,3})(G(\d{2,3}))?KT/;
            const match = metar.match(windPattern);
            
            if (match) {
                const directionStr = match[1];
                const speed = parseInt(match[2]);
                const gust = match[4] ? parseInt(match[4]) : null;
                
                if (directionStr === "VRB") {
                    return { direction: null, speed, gust };
                }
                
                return { 
                    direction: parseInt(directionStr), 
                    speed, 
                    gust 
                };
            }
            
            return { direction: null, speed: null, gust: null };
        }

        function calculateWindComponents(windSpeed, windFromDirection, runwayHeading) {
            if (windFromDirection === null || windSpeed === null) {
                return { headwind: null, crosswind: null };
            }
            
            const angleDiff = windFromDirection - runwayHeading;
            const angleRad = (angleDiff * Math.PI) / 180;

            const headwind = windSpeed * Math.cos(angleRad);
            const crosswind = windSpeed * Math.sin(angleRad);
            
            return { headwind, crosswind };
        }

        function getRunwayHeading(runway) {
            const match = runway.match(/(\d{2})/);
            if (match) {
                return parseInt(match[1]) * 10;
            }
            return null;
        }

        function getVisibility(metar, runway) {
            if (!metar) return "N/A";

            if (metar.includes("CAVOK")) {
                return "9999";
            }

            // RVR (e.g. R27R/0600)
            const rw = runway.padStart(2, '0');
            const rvrPattern = new RegExp(`R${rw}[LCR]?/(\\d{4})`);
            const rvrMatch = metar.match(rvrPattern);
            if (rvrMatch) {
                return rvrMatch[1];
            }

            // Statute miles (e.g. 3SM)
            const smMatch = metar.match(/(\d+)SM/);
            if (smMatch) {
                return String(parseInt(smMatch[1]) * 1609);
            }

            // Plain visibility (e.g. 4000)
            const visMatch = metar.match(/\b(\d{4})\b/);
            if (visMatch) {
                return visMatch[1];
            }

            return "N/A";
        }

        async function fetchMETAR(icao) {
            const url = `https://metar.vatsim.net/${icao}`;
            try {
                const response = await fetch(url);
                if (response.ok) {
                    const metarText = await response.text();
                    if (metarText && metarText.trim() && !metarText.startsWith("No METAR")) {
                        return metarText;
                    }
                }
            } catch (error) {
                console.error('METAR fetch error:', error);
            }
            return null;
        }

        function loadAirportData(airport) {
            return AIRPORT_DATA[airport.toLowerCase()] || null;
        }

        // ============================================
        // CORE LOGIC
        // ============================================

        function calculateMinima(airport, runway, aircraft, approach) {
            airport = airport.toLowerCase();
            aircraft = aircraft.toUpperCase();

            const data = loadAirportData(airport);
            if (!data) return { error: "Unknown airport" };
            
            if (!AIRCRAFT_MAP[aircraft]) return { error: "Unknown aircraft" };

            const category = AIRCRAFT_MAP[aircraft];

            // Reconstruct the JSON key
            let key;
            if (approach.startsWith("rnp-")) {
                const suffix = approach.split("-")[1];
                key = suffix === "approach" ? `rnp${runway}` : `rnp${runway}-${suffix}`;
            } else {
                key = `${approach}${runway}`;
            }

            if (!data[key] || !data[key][category]) {
                return { error: `Minima not defined for ${key} (Cat ${category})` };
            }

            const val = data[key][category];
            const required = String(val).match(/^\d+$/) ? parseInt(val) : 0;

            return {
                airport: airport.toUpperCase(),
                runway,
                required,
                key,
                category
            };
        }

        async function checkMinimaWithWeather(airport, runway, aircraft, approach) {
            const minimaData = calculateMinima(airport, runway, aircraft, approach);
            
            if (minimaData.error) {
                return minimaData;
            }

            const metar = await fetchMETAR(airport.toUpperCase());
            
            if (metar === null) {
                return {
                    ...minimaData,
                    visibility: "N/A",
                    status: "METAR UNAVAILABLE",
                    metar: "No METAR data available for this aerodrome",
                    wind: null
                };
            }

            const visibility = getVisibility(metar, runway);
            const windParsed = parseWindData(metar);
            const runwayHeading = getRunwayHeading(runway);
            
            let windData = null;
            if (windParsed.direction !== null && windParsed.speed !== null && runwayHeading !== null) {
                const { headwind, crosswind } = calculateWindComponents(
                    windParsed.speed, 
                    windParsed.direction, 
                    runwayHeading
                );
                
                windData = {
                    direction: windParsed.direction,
                    speed: windParsed.speed,
                    gust: windParsed.gust,
                    headwind: Math.round(headwind * 10) / 10,
                    crosswind: Math.round(crosswind * 10) / 10,
                    variable: false
                };
            } else if (windParsed.speed !== null) {
                windData = {
                    direction: "VRB",
                    speed: windParsed.speed,
                    gust: windParsed.gust,
                    headwind: null,
                    crosswind: null,
                    variable: true
                };
            }

            let status;
            if (minimaData.required === 0) {
                status = "UNAVAILABLE";
            } else {
                status = "ABOVE MINIMA";
                if (visibility.match(/^\d+$/) && parseInt(visibility) < minimaData.required) {
                    status = "BELOW MINIMA";
                }
            }

            return {
                ...minimaData,
                visibility,
                status,
                metar,
                wind: windData
            };
        }

        async function recommendApproach(airport, runway, aircraft) {
            airport = airport.toLowerCase();
            runway = runway.toUpperCase();
            aircraft = aircraft.toUpperCase();

            const data = loadAirportData(airport);
            if (!data) return { error: "Unknown airport" };

            if (!AIRCRAFT_MAP[aircraft]) return { error: "Unknown aircraft" };

            const category = AIRCRAFT_MAP[aircraft];

            const ilsGls = [];
            const others = [];

            // Collect approaches
            for (const key in data) {
                console.log('Checking key:', key);
                if (!data[key][category]) continue;

                // RNP approaches
                const rnpMatch = key.match(new RegExp(`^rnp${runway}(?:-(.+))?$`));
                if (rnpMatch) {
                    const suffix = rnpMatch[1] || "approach";
                    others.push(`rnp-${suffix.toLowerCase()}`);
                    continue;
                }

                // ILS / GLS
                if ((key.startsWith("il") || key.startsWith("gl")) && key.endsWith(runway)) {
                    const prefix = key.slice(0, -runway.length);
                    ilsGls.push(prefix);
                } else if (key.endsWith(runway)) {
                    const prefix = key.slice(0, -runway.length);
                    others.push(prefix);
                }
            }

            if (ilsGls.length === 0 && others.length === 0) {
                return { error: "No approaches available for this runway" };
            }

            // Test if METAR is available
            const testPrefix = ilsGls.length > 0 ? ilsGls[0] : others[0];
            const testResult = await checkMinimaWithWeather(airport, runway, aircraft, testPrefix);
            
            const metarUnavailable = testResult.status === "METAR UNAVAILABLE";

            // If METAR unavailable, recommend lowest requirement
            if (metarUnavailable) {
                const allApproaches = [];
                
                const catRank = (prefix) => {
                    if (prefix.startsWith("il")) return parseInt(prefix[2]);
                    if (prefix.startsWith("gl")) return parseInt(prefix[3]);
                    return 999;
                };
                
                for (const prefix of ilsGls) {
                    const result = calculateMinima(airport, runway, aircraft, prefix);
                    if (result.required > 0) {
                        allApproaches.push([catRank(prefix), result.required, prefix]);
                    }
                }
                
                for (const prefix of others) {
                    const result = calculateMinima(airport, runway, aircraft, prefix);
                    if (result.required > 0) {
                        allApproaches.push([999, result.required, prefix]);
                    }
                }
                
                if (allApproaches.length > 0) {
                    allApproaches.sort((a, b) => a[0] - b[0] || a[1] - b[1]);
                    return {
                        recommended: allApproaches[0][2],
                        metar_unavailable: true,
                        message: "No METAR available - recommended approach has lowest visibility requirement"
                    };
                }
                
                return { error: "No approaches available with defined minima" };
            }

            // ILS / GLS logic (CAT I → CAT III)
            if (ilsGls.length > 0) {
                const catRank = (p) => {
                    if (p.startsWith("il")) return parseInt(p[2]);
                    if (p.startsWith("gl")) return parseInt(p[3]);
                    return 9;
                };

                ilsGls.sort((a, b) => catRank(a) - catRank(b));

                for (const prefix of ilsGls) {
                    const result = await checkMinimaWithWeather(airport, runway, aircraft, prefix);
                    if (result.status === "ABOVE MINIMA") {
                        return { recommended: prefix };
                    }
                }
            }

            // No ILS/GLS → lowest RVR requirement wins
            const candidates = [];

            for (const prefix of others) {
                const result = await checkMinimaWithWeather(airport, runway, aircraft, prefix);
                
                if (result.status !== "ABOVE MINIMA") continue;
                if (!result.required || result.required <= 0) continue;
                
                candidates.push([result.required, prefix]);
            }

            if (candidates.length > 0) {
                candidates.sort((a, b) => a[0] - b[0]);
                return { recommended: candidates[0][1] };
            }

            return { error: "No suitable approach above minima" };
        }

        // ============================================
        // TRANSLATION FUNCTIONS
        // ============================================

        function translate() {
            const t = translations[currentLang];
            console.log('Translating to:', currentLang);
            
            // Update all elements with data-i18n attribute
            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                if (t[key]) {
                    element.textContent = t[key];
                    console.log('Updated', key, 'to', t[key]);
                }
            });
            
            // Reload dropdowns to update airport names
            if (airportSel.options.length > 0) {
                console.log('Reloading airports');
                loadAirports();
            }
            if (aircraftSel.options.length > 0) {
                console.log('Reloading aircraft');
                loadAircraft();
            }
            
            // Update placeholder options
            updateDropdownPlaceholders();
        }

        function updateDropdownPlaceholders() {
            const t = translations[currentLang];
            if (airportSel.options[0]) airportSel.options[0].textContent = t.selectAirport;
            if (runwaySel.options[0]) runwaySel.options[0].textContent = t.selectRunway;
            if (aircraftSel.options[0]) aircraftSel.options[0].textContent = t.selectAircraft;
            if (approachSel.options[0]) approachSel.options[0].textContent = t.selectApproach;
        }

        function getTranslatedAirportName(code) {
            const t = translations[currentLang];
            const upperCode = code.toUpperCase();
            if (t.airports && t.airports[upperCode]) {
                return t.airports[upperCode];
            }
            // Fallback to data if not in translations
            if (AIRPORT_DATA[code] && AIRPORT_DATA[code].name) {
                return AIRPORT_DATA[code].name;
            }
            return "";
        }

        // ============================================
        // UI FUNCTIONS
        // ============================================

        const airportSel = document.getElementById('airport');
        const aircraftSel = document.getElementById('aircraft');
        const runwaySel = document.getElementById('runway');
        const approachSel = document.getElementById('approach');
        const checkBtn = document.getElementById('checkBtn');
        const magicWand = document.getElementById('magicWand');
        const resultDiv = document.getElementById('result');

        function loadAirports() {
            const t = translations[currentLang];
            const currentValue = airportSel.value;
            airportSel.innerHTML = `<option value="">${t.selectAirport}</option>`;
            const airports = Object.keys(AIRPORT_DATA).map(code => ({
                code: code.toUpperCase(),
                name: getTranslatedAirportName(code)
            }));
            airports.sort((a, b) => a.code.localeCompare(b.code));
            airports.forEach(ap => {
                const option = new Option(`${ap.code}${ap.name ? ' - ' + ap.name : ''}`, ap.code);
                airportSel.add(option);
            });
            airportSel.value = currentValue;
        }

        function loadAircraft() {
            const t = translations[currentLang];
            const currentValue = aircraftSel.value;
            aircraftSel.innerHTML = `<option value="">${t.selectAircraft}</option>`;
            const aircraft = Object.keys(AIRCRAFT_MAP).sort();
            aircraft.forEach(ac => aircraftSel.add(new Option(ac, ac)));
            aircraftSel.value = currentValue;
        }

        function loadRunways() {
            const t = translations[currentLang];
            approachSel.innerHTML = `<option value="">${t.selectApproach}</option>`;
            approachSel.disabled = true;
            runwaySel.value = "";
            runwaySel.disabled = true;
            runwaySel.innerHTML = '<option value="">Loading...</option>';
            
            if (!airportSel.value) return;

            const data = loadAirportData(airportSel.value);
            if (!data) {
                runwaySel.innerHTML = '<option value="">No data</option>';
                return;
            }

            const runways = new Set();

            for (const key in data) {
                const match = key.match(/(\d{2}[LRC]?)(?:-[a-z0-9]+)?$/);
                if (match) {
                    runways.add(match[1]);
                }
            }

            runwaySel.innerHTML = `<option value="">${t.selectRunway}</option>`;
            Array.from(runways).sort().forEach(rw => runwaySel.add(new Option(rw, rw)));
            runwaySel.disabled = false;
            updateUI();
        }

        function loadApproaches() {
            const t = translations[currentLang];
            if (!aircraftSel.value) {
                approachSel.innerHTML = `<option value="">${t.selectAircraft}</option>`;
                return;
            }

            approachSel.disabled = true;
            approachSel.innerHTML = '<option value="">Loading...</option>';

            const airport = airportSel.value.toLowerCase();
            const runway = runwaySel.value.toUpperCase();
            const aircraft = aircraftSel.value.toUpperCase();

            const data = loadAirportData(airport);
            if (!data || !runway) {
                approachSel.innerHTML = '<option value="">No data</option>';
                return;
            }

            const category = AIRCRAFT_MAP[aircraft];
            const approaches = [];

            for (const key in data) {
                const minima = data[key];

                // RNP approaches
                const rnpMatch = key.match(new RegExp(`^rnp${runway}(?:-(.+))?$`));
                if (rnpMatch) {
                    const suffix = rnpMatch[1] || "approach";
                    approaches.push({
                        type: "RNP",
                        label: `RNP ${suffix.toUpperCase()}`,
                        value: `rnp-${suffix.toLowerCase()}`,
                        required: category ? minima[category] : null
                    });
                    continue;
                }

                // ILS / GLS / others
                const match = key.match(/^([a-z]{2,4}[123]?)(\d{2}[LRC]?)$/);
                if (!match || match[2] !== runway) continue;

                const prefix = match[1];
                let label, type;

                if (prefix.startsWith("il")) {
                    label = `ILS CAT ${prefix[2]}`;
                    type = "ILS";
                } else if (prefix.startsWith("gl")) {
                    label = `GLS CAT ${prefix[prefix.length - 1]}`;
                    type = "GLS";
                } else if (prefix.toLowerCase().startsWith("crc")) {
                    label = "CIRCLING";
                    type = "CIRCLING";
                } else if (prefix.toLowerCase().startsWith("vis")) {
                    label = "VISUAL";
                    type = "VISUAL";
                } else {
                    label = prefix.toUpperCase();
                    type = label;
                }

                approaches.push({
                    type,
                    label,
                    value: prefix,
                    required: category ? minima[category] : null
                });
            }

            approachSel.innerHTML = `<option value="">${t.selectApproach}</option>`;
            approaches.forEach(ap => approachSel.add(new Option(ap.label, ap.value)));

            approachSel.disabled = false;
            updateUI();
        }

        function updateUI() {
            const allSelected = airportSel.value && runwaySel.value && aircraftSel.value && approachSel.value;
            checkBtn.disabled = !allSelected;

            const canRecommend = airportSel.value && runwaySel.value && aircraftSel.value && approachSel.options.length > 1;
            magicWand.style.display = canRecommend ? "flex" : "none";
        }

        async function onRecommendApproach() {
            const t = translations[currentLang];
            if (magicWand.classList.contains("loading")) return;

            magicWand.classList.add("loading");

            try {
                const data = await recommendApproach(
                    airportSel.value,
                    runwaySel.value,
                    aircraftSel.value
                );

                if (data.recommended) {
                    approachSel.value = data.recommended;
                    updateUI();
                    
                    if (data.metar_unavailable) {
                        resultDiv.className = "result show warning";
                        resultDiv.innerHTML = `
                            <p style="font-size: 1.1em; margin-top:0;"><strong>${t.noWeatherData}</strong></p>
                            <p style="margin: 10px 0;">${data.message || t.noWeatherMessage}</p>
                        `;
                    }
                } else if (data.error) {
                    alert("Error: " + data.error);
                }
            } catch (e) {
                console.error(e);
                alert(t.errorRecommending);
            } finally {
                magicWand.classList.remove("loading");
            }
        }

        function formatWindComponents(wind) {
            const t = translations[currentLang];
            if (!wind) return '';
            
            if (wind.variable) {
                let windText = `<div class="wind-components">
                    <div class="wind-item">
                        <span class="wind-label">${t.windSpeed}</span>
                        <span class="wind-value">VRB ${wind.speed}kt</span>
                    </div>`;
                
                if (wind.gust) {
                    windText += `
                    <div class="wind-item">
                        <span class="wind-label">${t.gusting}</span>
                        <span class="wind-value">${wind.gust}kt</span>
                    </div>`;
                }
                
                windText += `</div>
                    <p style="font-size: 0.85em; color: #ffa726; margin: 10px 0;">${t.windVariable}</p>`;
                return windText;
            }
            
            let html = '<div class="wind-components">';
            
            // Headwind/Tailwind
            const hw = wind.headwind;
            if (hw >= 0) {
                html += `
                    <div class="wind-item">
                        <span class="wind-label">${t.headwind}</span>
                        <span class="wind-value headwind">${Math.abs(hw).toFixed(1)}kt</span>
                    </div>`;
            } else {
                html += `
                    <div class="wind-item">
                        <span class="wind-label">${t.tailwind}</span>
                        <span class="wind-value tailwind">${Math.abs(hw).toFixed(1)}kt</span>
                    </div>`;
            }
            
            // Crosswind
            const xw = wind.crosswind;
            const xwDir = xw > 0 ? 'Right' : xw < 0 ? 'Left' : '';
            html += `
                <div class="wind-item">
                    <span class="wind-label">${t.crosswind} ${xwDir}</span>
                    <span class="wind-value crosswind">${Math.abs(xw).toFixed(1)}kt</span>
                </div>`;
            
            // Wind direction and speed
            html += `
                <div class="wind-item">
                    <span class="wind-label">${t.windFrom}</span>
                    <span class="wind-value">${wind.direction}°</span>
                </div>`;
            
            html += `
                <div class="wind-item">
                    <span class="wind-label">${t.windSpeed}</span>
                    <span class="wind-value">${wind.speed}kt</span>
                </div>`;
            
            html += '</div>';
            
            if (wind.gust) {
                html += `<p style="font-size: 0.85em; color: #ffa726; margin: 10px 0;">${t.gusting} ${wind.gust}kt</p>`;
            }
            
            return html;
        }

        async function onCheckMinima() {
            const t = translations[currentLang];
            resultDiv.innerHTML = "Fetching weather...";
            resultDiv.className = "result show neutral";

            const data = await checkMinimaWithWeather(
                airportSel.value,
                runwaySel.value,
                aircraftSel.value,
                approachSel.value
            );

            if (data.error) {
                resultDiv.innerHTML = `<p style="color:var(--error)">${data.error}</p>`;
                return;
            }

            let colorClass = "neutral";
            if (data.status.includes("BELOW")) colorClass = "red";
            if (data.status.includes("ABOVE")) colorClass = "green";
            if (data.status === "UNAVAILABLE") colorClass = "neutral";
            if (data.status === "METAR UNAVAILABLE") colorClass = "warning";

            resultDiv.className = `result show ${colorClass}`;
            
            if (data.status === "METAR UNAVAILABLE") {
                resultDiv.innerHTML = `
                    <p style="font-size: 1.2em; margin-top:0;"><strong>${t.metarUnavailable}</strong></p>
                    <p style="margin: 10px 0;">${t.noCurrentWeather}</p>
                    <div style="margin-top: 15px;">
                        <span>${t.required}: <strong>${data.required}m</strong></span>
                    </div>
                    <label style="margin-top: 15px;">${t.metarStatus}</label>
                    <pre>${data.metar}</pre>
                `;
            } else {
                const displayStatus = data.status === "ABOVE MINIMA" ? t.aboveMinima : t.belowMinima;
                
                resultDiv.innerHTML = `
                    <p style="font-size: 1.2em; margin-top:0;"><strong>${displayStatus}</strong></p>
                    <div class="visibility-box">
                        <div class="visibility-item">
                            <span class="visibility-label">${t.required}</span>
                            <span class="visibility-value">${data.required}m</span>
                        </div>
                        <div class="visibility-item">
                            <span class="visibility-label">${t.actual}</span>
                            <span class="visibility-value">${data.visibility}m</span>
                        </div>
                    </div>
                    ${formatWindComponents(data.wind)}
                    <label>${t.currentMetar}</label>
                    <pre>${data.metar}</pre>
                `;
            }
        }

        // Event listeners
        airportSel.addEventListener('change', loadRunways);
        runwaySel.addEventListener('change', loadApproaches);
        aircraftSel.addEventListener('change', () => {
            if (runwaySel.value) loadApproaches();
        });
        approachSel.addEventListener('change', updateUI);
        checkBtn.addEventListener('click', onCheckMinima);
        magicWand.addEventListener('click', onRecommendApproach);

        // Language dropdown event listener
        document.getElementById('langSelect').addEventListener('change', function() {
            console.log('Language dropdown changed from', currentLang, 'to', this.value);
            currentLang = this.value;
            translate();
            localStorage.setItem('language', currentLang);
        });

        // Load saved language preference and initialize
        window.addEventListener('DOMContentLoaded', () => {
            const savedLang = localStorage.getItem('language') || 'en';
            currentLang = savedLang;
            document.getElementById('langSelect').value = currentLang;
            translate();
            updateUI();
        });
    </script>
    <div class="settings-modal" id="settingsModal">
        <div class="settings-content">
            <div class="settings-header">
                <h2>Settings</h2>
                <button class="close-btn" onclick="closeSettings()">&times;</button>
            </div>

            <!-- Discord Section -->
            <div class="discord-section">
                <h3 style="margin-top: 0;">Discord Integration</h3>
                
                <!-- Not Connected State -->
                <div id="discordNotConnected" style="display: none;">
                    <div class="discord-status">
                        <span class="status-indicator"></span>
                        <span>Not Connected</span>
                    </div>
                    <p style="font-size: 0.9em; color: #aaa;">
                        Connect your Discord account to receive real-time weather alerts and notifications.
                    </p>
                    <button class="settings-btn" onclick="connectDiscord()">
                        Connect Discord
                    </button>
                </div>

                <!-- Connected State -->
                <div id="discordConnected" style="display: none;">
                    <div class="discord-status">
                        <span class="status-indicator connected"></span>
                        <span>Connected</span>
                    </div>
                    
                    <div class="discord-info">
                        <img id="discordAvatar" class="discord-avatar" src="" alt="Avatar">
                        <div>
                            <strong id="discordUsername"></strong>
                            <div style="font-size: 0.85em; color: #888;">Discord Account</div>
                        </div>
                    </div>

                    <div class="notification-toggle">
                        <span>Enable Notifications</span>
                        <div class="toggle-switch" id="notificationToggle" onclick="toggleNotifications()">
                            <div class="toggle-slider"></div>
                        </div>
                    </div>

                    <button class="settings-btn secondary" onclick="sendTestDM()">
                        Send Test Message
                    </button>
                    
                    <button class="settings-btn danger" onclick="disconnectDiscord()">
                        Disconnect Discord
                    </button>
                </div>
            </div>
        </div>
    </div>
    <script>
        const API_URL = 'https://minima-discord-backend-production.up.railway.app';
        
        // Discord connection state
        let discordUser = null;
        let notificationsEnabled = true;
        let sessionToken = null;
        
        // Get session token from localStorage
        function getSessionToken() {
            return localStorage.getItem('minima_session_token');
        }
        
        // Save session token to localStorage
        function saveSessionToken(token) {
            localStorage.setItem('minima_session_token', token);
            sessionToken = token;
        }
        
        // Clear session token
        function clearSessionToken() {
            localStorage.removeItem('minima_session_token');
            sessionToken = null;
        }
        
        // Add token to fetch requests
        function fetchWithAuth(url, options = {}) {
            const token = getSessionToken();
            
            if (token) {
                options.headers = {
                    ...options.headers,
                    'X-Session-Token': token
                };
            }
            
            options.credentials = 'include';
            
            return fetch(url, options);
        }
        
        // Check if user is authenticated on page load
        window.addEventListener('DOMContentLoaded', () => {
            checkAuthStatus();
            
            // Check if redirected from Discord OAuth
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('auth') === 'success') {
                const username = urlParams.get('user');
                const token = urlParams.get('token');
                
                // Save token to localStorage
                if (token) {
                    saveSessionToken(token);
                    console.log('Session token saved!');
                }
                
                alert(`Successfully connected to Discord! Welcome, ${username}!`);
                
                // Clean URL
                window.history.replaceState({}, document.title, window.location.pathname);
                
                checkAuthStatus();
            }
        });
        
        async function checkAuthStatus() {
            try {
                const response = await fetchWithAuth(`${API_URL}/api/user/me`);
                
                if (response.ok) {
                    discordUser = await response.json();
                    console.log('User authenticated:', discordUser.username);
                    updateDiscordUI(true);
                } else {
                    console.log('Not authenticated, clearing token');
                    clearSessionToken();
                    updateDiscordUI(false);
                }
            } catch (error) {
                console.error('Error checking auth status:', error);
                clearSessionToken();
                updateDiscordUI(false);
            }
        }
        
        function updateDiscordUI(connected) {
            const connectedDiv = document.getElementById('discordConnected');
            const notConnectedDiv = document.getElementById('discordNotConnected');
            
            if (connected && discordUser) {
                connectedDiv.style.display = 'block';
                notConnectedDiv.style.display = 'none';
                
                document.getElementById('discordUsername').textContent = discordUser.username;
                
                // Set avatar
                if (discordUser.avatar) {
                    const avatarUrl = `https://cdn.discordapp.com/avatars/${discordUser.discord_id}/${discordUser.avatar}.png`;
                    document.getElementById('discordAvatar').src = avatarUrl;
                } else {
                    document.getElementById('discordAvatar').src = 'https://cdn.discordapp.com/embed/avatars/0.png';
                }
                
                // Update notification toggle
                notificationsEnabled = discordUser.notifications_enabled;
                const toggle = document.getElementById('notificationToggle');
                if (notificationsEnabled) {
                    toggle.classList.add('active');
                } else {
                    toggle.classList.remove('active');
                }
            } else {
                connectedDiv.style.display = 'none';
                notConnectedDiv.style.display = 'block';
            }
        }
        
        async function connectDiscord() {
            try {
                const response = await fetch(`${API_URL}/api/discord/auth-url`);
                const data = await response.json();
                
                if (data.auth_url) {
                    window.location.href = data.auth_url;
                }
            } catch (error) {
                console.error('Error getting Discord auth URL:', error);
                alert('Failed to connect to Discord. Please try again.');
            }
        }
        
        async function disconnectDiscord() {
            if (!confirm('Are you sure you want to disconnect your Discord account?')) {
                return;
            }
            
            try {
                const response = await fetchWithAuth(`${API_URL}/api/user/disconnect`, {
                    method: 'POST'
                });
                
                if (response.ok) {
                    discordUser = null;
                    clearSessionToken();
                    updateDiscordUI(false);
                    alert('Discord account disconnected successfully.');
                }
            } catch (error) {
                console.error('Error disconnecting Discord:', error);
                alert('Failed to disconnect. Please try again.');
            }
        }
        
        async function toggleNotifications() {
            if (!discordUser) return;
            
            notificationsEnabled = !notificationsEnabled;
            const toggle = document.getElementById('notificationToggle');
            
            if (notificationsEnabled) {
                toggle.classList.add('active');
            } else {
                toggle.classList.remove('active');
            }
            
            try {
                await fetchWithAuth(`${API_URL}/api/user/notifications/toggle`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled: notificationsEnabled })
                });
            } catch (error) {
                console.error('Error toggling notifications:', error);
            }
        }
        
        async function sendTestDM() {
            try {
                const response = await fetchWithAuth(`${API_URL}/api/discord/test-dm`, {
                    method: 'POST'
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    alert('Test message sent! Check your Discord DMs.');
                } else {
                    alert(data.error || 'Failed to send test message.');
                }
            } catch (error) {
                console.error('Error sending test DM:', error);
                alert('Failed to send test message. Please try again.');
            }
        }
        
        function openSettings() {
            document.getElementById('settingsModal').classList.add('show');
        }
        
        function closeSettings() {
            document.getElementById('settingsModal').classList.remove('show');
        }
        
        // Close modal when clicking outside
        document.getElementById('settingsModal').addEventListener('click', (e) => {
            if (e.target.id === 'settingsModal') {
                closeSettings();
            }
        });
    </script>

</body>
</html>





