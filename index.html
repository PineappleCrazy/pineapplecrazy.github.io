<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minima</title>
    <link rel="icon" type="image/x-icon" href="minima.ico">
    <style>
            :root {
                --bg-color: #121212;
                --card-bg: #1e1e1e;
                --text-main: #e0e0e0;
                --accent: #485BAB;
                --accent-hover: #5a6fc4;
                --error: #ff5252;
                --border: #333;
                --warning: #ffa726;
            }

            html {
                background-color: var(--bg-color);
            }

            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                color: var(--text-main);
                display: flex;
                flex-direction: column;
                align-items: center;
                padding: 20px;
                margin: 0;
                min-height: 100vh;
            }

            body::before {
                content: "";
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-image: url('background.png');
                background-size: cover;
                background-position: center;
                background-attachment: fixed;
                opacity: 0.05;
                z-index: -1;
            }

        .container {
            width: 100%;
            max-width: 500px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: var(--accent);
            margin-bottom: 5px;
        }

        /* Language Dropdown in Corner */
        .language-selector {
            position: fixed;
            top: 15px;
            right: 15px;
            z-index: 1000;
        }

        .language-selector select {
            padding: 6px 10px;
            background: rgba(30, 30, 30, 0.9);
            border: 1px solid var(--border);
            color: var(--text-main);
            border-radius: 6px;
            font-size: 0.85em;
            cursor: pointer;
            appearance: auto;
            min-width: 80px;
            backdrop-filter: blur(10px);
        }

        .language-selector select:hover {
            border-color: var(--accent);
        }

        .language-selector select:focus {
            outline: none;
            border-color: var(--accent);
        }

        @media (max-width: 600px) {
            .language-selector {
                top: 10px;
                right: 10px;
            }
        }

        .info-box {
            background: #2c2c2c;
            padding: 15px;
            border-radius: 8px;
            font-size: 0.9em;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
        }

        .card {
            background: var(--card-bg);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 1px solid var(--border);
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            font-size: 0.85em;
            text-transform: uppercase;
            color: #888;
        }

        select {
            width: 100%;
            padding: 12px;
            margin-bottom: 20px;
            background: #252525;
            border: 1px solid var(--border);
            color: white;
            border-radius: 6px;
            appearance: none;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .input-group select {
            margin-bottom: 0;
            flex-grow: 1;
        }

        .magic-btn {
            display: none;
            align-items: center;
            justify-content: center;
            width: 46px;
            height: 46px;
            background: #2c2c2c;
            border: 1px solid var(--accent);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            padding: 0;
            overflow: hidden;
            color: white;
        }

        .magic-icon {
            width: 24px;
            height: 24px;
            object-fit: contain;
            pointer-events: none;
        }

        .magic-btn:hover {
            background: var(--accent);
            border-color: white;
        }

        .magic-btn.loading {
            animation: spin 1s linear infinite;
            cursor: wait;
            opacity: 0.5;
        }

        @keyframes spin { 
            100% { transform: rotate(360deg); } 
        }

        button.main-btn {
            width: 100%;
            padding: 15px;
            background: var(--accent);
            color: black;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        button.main-btn:disabled {
            background: #444;
            color: #888;
            cursor: not-allowed;
        }

        .result {
            margin-top: 25px;
            padding: 20px;
            border-radius: 8px;
            display: none;
        }

        .result.show { display: block; }
        .red { border: 2px solid var(--error); background: rgba(255, 82, 82, 0.1); }
        .green { border: 2px solid var(--accent); background: rgba(0, 230, 118, 0.1); }
        .neutral { border: 2px solid #555; background: #222; }
        .warning { border: 2px solid var(--warning); background: rgba(255, 167, 38, 0.1); }

        .visibility-box {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(72, 91, 171, 0.15);
            border: 2px solid var(--accent);
            border-radius: 8px;
        }

        .visibility-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .visibility-label {
            font-size: 0.8em;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .visibility-value {
            font-size: 1.3em;
            font-weight: bold;
            color: white;
        }

        .wind-components {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
            padding: 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            border: 1px solid #333;
        }

        .wind-item {
            display: flex;
            flex-direction: column;
        }

        .wind-label {
            font-size: 0.75em;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 3px;
        }

        .wind-value {
            font-size: 1.0em;
            font-weight: bold;
        }

        .headwind { color: #4CAF50; }
        .tailwind { color: #ff5252; }
        .crosswind { color: #ffa726; }

        .pre {
            background: #000;
            padding: 10px;
            color: #0f0;
            font-size: 0.8em;
            overflow-x: auto;
            border-radius: 4px;
        }

        .footer {
            margin-top: 40px;
            padding: 20px;
            text-align: center;
            font-size: 0.8em;
            color: #888;
            border-top: 1px solid var(--border);
            box-sizing: border-box;
            width: 100%;
        }

        .footer a {
            color: var(--accent);
            text-decoration: none;
        }

        .container {
            width: 100%;
            max-width: 500px;
            position: relative;
        }

        .image-box {
            width: 100%;
            margin-top: 20px;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid var(--border);
            background: var(--card-bg);
            line-height: 0;
        }

        .image-box img {
            width: 100%;
            height: auto;
            display: block;
        }
    </style>
    <style>
    /* Discord Settings Menu Styles */
        .settings-icon {
            position: fixed;
            top: 15px;
            left: 15px;
            width: 40px;
            height: 40px;
            background: rgba(30, 30, 30, 0.9);
            border: 1px solid var(--border);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 1000;
        }

        .settings-icon:hover {
            background: var(--accent);
            border-color: white;
        }

        .settings-icon svg {
            width: 20px;
            height: 20px;
            fill: var(--text-main);
        }

        .settings-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .settings-modal.show {
            display: flex;
        }

        .settings-content {
            background: var(--card-bg);
            padding: 30px;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            border: 1px solid var(--border);
            max-height: 80vh;
            overflow-y: auto;
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .settings-header h2 {
            margin: 0;
            color: var(--accent);
        }

        .close-btn {
            background: none;
            border: none;
            color: var(--text-main);
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover {
            color: var(--accent);
        }

        .discord-section {
            margin-bottom: 25px;
            padding: 20px;
            background: #252525;
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .discord-status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--error);
        }

        .status-indicator.connected {
            background: #485BAB;
        }

        .discord-info {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
        }

        .discord-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid var(--accent);
        }

        .settings-btn {
            width: 100%;
            padding: 12px;
            margin-top: 10px;
            background: var(--accent);
            color: black;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .settings-btn:hover {
            opacity: 0.8;
        }

        .settings-btn.secondary {
            background: #444;
            color: white;
        }

        .settings-btn.danger {
            background: var(--error);
            color: white;
        }

        .notification-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: #2c2c2c;
            border-radius: 6px;
            margin-top: 15px;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background: #444;
            border-radius: 13px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: var(--accent);
        }

        .toggle-slider {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(24px);
        }
</style>
</head>
<body>
    <div class="language-selector">
        <select id="langSelect">
            <option value="en">EN</option>
            <option value="no">NO</option>
        </select>
    </div>

    <div class="container">
        <div class="header">
            <h1 style="color:#FFFFFF;" data-i18n="title">Minima</h1>
            <p style="margin:0; color:#888;">Fly aware, Fly safe  ‚îã  97 Aerodromes</p>
        </div>

        <div class="info-box">
            <strong data-i18n="howItWorksTitle">How it works:</strong><br>
            <span data-i18n="howItWorksDesc1">Check the status of any supported approach. We'll reference it to</span> 
            <strong data-i18n="currentWeatherConditions">current weather conditions</strong> 
            <span data-i18n="howItWorksDesc2">and your</span> 
            <strong data-i18n="aircraftCapabilities">aircraft's capabilities</strong> 
            <span data-i18n="howItWorksDesc3">to let you know if it's safe to fly.</span>
            <br><br>
            <span data-i18n="howItWorksDesc4">Put in an aerodrome, runway and aircraft, then press the wand - we'll</span> 
            <strong data-i18n="recommend">recommend</strong> 
            <span data-i18n="howItWorksDesc5">the approach we think best suited.</span>
        </div>
        <div class="card">
            <label data-i18n="selectAirport">Aerodrome</label>
            <select id="airport">
                <option value="">Select Airport</option>
            </select>

            <label data-i18n="selectAircraft">Aircraft</label>
            <select id="aircraft">
                <option value="">Select Aircraft</option>
            </select>

            <label data-i18n="selectRunway">Runway</label>
            <select id="runway" disabled>
                <option value="">Select Airport First</option>
            </select>

            <div class="input-group">
                <div style="flex-grow: 1;">
                    <label data-i18n="selectApproach">Approach</label>
                    <select id="approach" disabled>
                        <option value="">Select Runway First</option>
                    </select>
                </div>
                <div style="align-self: flex-end;">
                    <button class="magic-btn" id="magicWand" title="Recommend best approach">
                        <svg class="magic-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <path d="M15 4V2M15 16v-2M8 9h2M20 9h2M17.8 11.8L19 13M17.8 6.2L19 5M3 21l9-9M12.2 6.2L11 5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </button>
                </div>
            </div>

            <button class="main-btn" id="checkBtn" disabled data-i18n="checkMinima">Check Minima</button>

            <div class="result" id="result"></div>
        </div>
        <style>
            
        .vatsim-card {
            background: var(--card-bg);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 1px solid var(--border);
            margin-top: 30px;
            position: relative;
        }
        
        .vatsim-card::before {
            content: "LIVE";
            position: absolute;
            top: -10px;
            right: 20px;
            background: #485BAB;
            color: #000;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.7em;
            font-weight: bold;
            letter-spacing: 1px;
            animation: pulse-live 2s infinite;
        }
        
        @keyframes pulse-live {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(0.98); }
        }
        
        .vatsim-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--accent);
        }
        
        .vatsim-header svg {
            width: 28px;
            height: 28px;
            fill: var(--accent);
        }
        
        .vatsim-header h2 {
            margin: 0;
            color: var(--accent);
            font-size: 1.3em;
        }
        
        .vatsim-info-box {
            background: rgba(72, 91, 171, 0.1);
            border-left: 4px solid var(--accent);
            padding: 12px;
            margin-bottom: 20px;
            border-radius: 6px;
            font-size: 0.9em;
        }
        
        .tracker-status {
            background: #2c2c2c;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid var(--border);
            transition: all 0.3s ease;
        }
        
        .tracker-status.active {
            border-color: #485BAB;
            background: rgba(0, 255, 0, 0.05);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.1);
        }
        
        .status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .status-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .status-badge.inactive {
            background: #444;
            color: #999;
        }
        
        .status-badge.tracking {
            background: #485BAB;
            color: #000;
            animation: pulse-live 2s infinite;
        }
        
        .flight-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }
        
        .flight-info-item {
            background: #1a1a1a;
            padding: 8px;
            border-radius: 4px;
        }
        
        .flight-info-label {
            font-size: 0.7em;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .flight-info-value {
            font-size: 1.1em;
            font-weight: bold;
            color: var(--accent);
            margin-top: 2px;
        }
        
        .distance-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            padding: 12px;
            background: rgba(72, 91, 171, 0.1);
            border-radius: 6px;
        }
        
        .distance-bar {
            flex: 1;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }
        
        .distance-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, var(--accent));
            border-radius: 4px;
            transition: width 0.5s ease;
        }
        
        .distance-text {
            font-weight: bold;
            color: var(--accent);
            min-width: 70px;
            text-align: right;
            font-size: 1.1em;
        }
        
        .input-with-icon {
            position: relative;
            margin-bottom: 20px;
        }
        
        .input-with-icon input {
            width: 100%;
            padding: 12px 12px 12px 40px;
            background: #252525;
            border: 1px solid var(--border);
            color: white;
            border-radius: 6px;
            font-size: 1em;
            text-transform: uppercase;
            box-sizing: border-box;
        }
        
        .input-with-icon input:focus {
            outline: none;
            border-color: var(--accent);
            background: #2a2a2a;
        }
        
        .input-icon {
            position: absolute;
            left: 12px;
            top: 12px;
            width: 20px;
            height: 20px;
            fill: #666;
        }
        
        .runway-select {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            background: #252525;
            border: 1px solid var(--border);
            color: white;
            border-radius: 6px;
            font-size: 1em;
            cursor: pointer;
        }
        
        .runway-select:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .approach-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 20px;
            min-height: 40px;
        }
        
        .approach-chip {
            padding: 8px 16px;
            background: #2c2c2c;
            border: 2px solid var(--border);
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9em;
            font-weight: bold;
        }
        
        .approach-chip:hover {
            border-color: var(--accent);
            background: rgba(72, 91, 171, 0.2);
            transform: translateY(-2px);
        }
        
        .approach-chip.selected {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
        }
        
        .approach-chip.auto {
            background: linear-gradient(135deg, #485BAB, var(--accent));
            border-color: #485BAB;
            color: #000;
        }
        
        .tracker-actions {
            display: flex;
            gap: 10px;
        }
        
        .tracker-actions button {
            flex: 1;
            padding: 15px;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1em;
        }
        
        .btn-start {
            background: #485BAB;
            color: #000;
            cursor: pointer;
        }
        
        .btn-start:hover {
            background: #00cc00;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 0, 0.3);
        }
        
        .btn-start:disabled {
            background: #485BAB;
            color: #000;
            cursor: pointer;
            opacity: 1;
        }
        
        .btn-stop {
            background: var(--error);
            color: white;
        }
        
        .btn-stop:hover {
            background: #cc0000;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 82, 82, 0.3);
        }
        
        .tracker-message {
            margin-top: 15px;
        }
        
        .error-message {
            background: rgba(255, 82, 82, 0.1);
            border: 1px solid var(--error);
            padding: 12px;
            border-radius: 6px;
            color: var(--error);
            font-size: 0.9em;
        }
        
        .success-message {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #00ff00;
            padding: 12px;
            border-radius: 6px;
            color: #00ff00;
            font-size: 0.9em;
        }
        
        .info-message {
            background: rgba(72, 91, 171, 0.1);
            border: 1px solid var(--accent);
            padding: 12px;
            border-radius: 6px;
            color: var(--accent);
            font-size: 0.9em;
        }
        
        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 3px solid #444;
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Mobile responsive */
        @media (max-width: 600px) {
            .flight-info {
                grid-template-columns: 1fr;
            }
            
            .tracker-actions {
                flex-direction: column;
            }
            
            .distance-indicator {
                flex-direction: column;
                align-items: stretch;
            }
            
            .distance-text {
                text-align: center;
                margin-top: 8px;
            }
        }
        </style>
        
        <!-- VATSIM Tracker Card HTML -->
        <div class="vatsim-card" id="vatsimCard">
            <div class="vatsim-header">
                <svg viewBox="0 0 24 24" fill="currentColor">
                    <path d="M21 16v-2l-8-5V3.5c0-.83-.67-1.5-1.5-1.5S10 2.67 10 3.5V9l-8 5v2l8-2.5V19l-2 1.5V22l3.5-1 3.5 1v-1.5L13 19v-5.5l8 2.5z"/>
                </svg>
                <h2 data-i18n="vatsimTrackerTitle">Live Tracking</h2>
            </div>
        
            <div class="vatsim-info-box">
                <strong data-i18n="vatsimTrackerInfoTitle">Track Your Flight:</strong><br>
                <span data-i18n="vatsimTrackerInfoDesc">Enter your VATSIM callsign and runway. We'll monitor your position and send Discord alerts at 50nm and if weather deteriorates!</span>
            </div>
        
            <!-- Tracker Status Display -->
            <div class="tracker-status" id="trackerStatus">
                <div class="status-header">
                    <strong data-i18n="trackerStatusLabel">Tracker Status</strong>
                    <span class="status-badge inactive" id="statusBadge" data-i18n="statusNotTracking">NOT TRACKING</span>
                </div>
                <p style="margin: 5px 0 0 0; font-size: 0.85em; color: #888;" id="statusMessage">
                    <span data-i18n="statusMessageDefault">Connect Discord and enter callsign to start tracking</span>
                </p>
                
                <!-- Flight info (hidden until tracking) -->
                <div id="flightInfo" style="display: none;">
                    <div class="flight-info">
                        <div class="flight-info-item">
                            <div class="flight-info-label" data-i18n="infoCallsignLabel">Callsign</div>
                            <div class="flight-info-value" id="infoCallsign">‚Äî</div>
                        </div>
                        <div class="flight-info-item">
                            <div class="flight-info-label" data-i18n="infoDestinationLabel">Destination</div>
                            <div class="flight-info-value" id="infoDestination">‚Äî</div>
                        </div>
                        <div class="flight-info-item">
                            <div class="flight-info-label" data-i18n="infoRunwayLabel">Runway</div>
                            <div class="flight-info-value" id="infoRunway">‚Äî</div>
                        </div>
                        <div class="flight-info-item">
                            <div class="flight-info-label" data-i18n="infoApproachLabel">Approach</div>
                            <div class="flight-info-value" id="infoApproach">‚Äî</div>
                        </div>
                        <div class="flight-info-item">
                            <div class="flight-info-label" data-i18n="infoSpeedLabel">Speed</div>
                            <div class="flight-info-value" id="infoSpeed">‚Äî</div>
                        </div>
                        <div class="flight-info-item">
                            <div class="flight-info-label" data-i18n="infoAircraftLabel">Aircraft</div>
                            <div class="flight-info-value" id="infoAircraft">‚Äî</div>
                        </div>
                    </div>
                    
                    <!-- Distance indicator -->
                    <div class="distance-indicator">
                        <span style="font-size: 0.8em; color: #888;" data-i18n="distanceToDestLabel">Distance to destination:</span>
                        <div class="distance-bar">
                            <div class="distance-fill" id="distanceFill" style="width: 0%"></div>
                        </div>
                        <span class="distance-text" id="distanceText">‚Äî</span>
                    </div>
                </div>
            </div>
        
            <!-- Input Form -->
            <div id="trackerForm">
                <label style="display: block; margin-bottom: 8px; font-weight: bold; font-size: 0.85em; text-transform: uppercase; color: #888;">
                    <span data-i18n="callsignInputLabel">VATSIM Callsign</span>
                </label>
                <div class="input-with-icon">
                    <svg class="input-icon" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M7.07,18.28C7.5,17.38 10.12,16.5 12,16.5C13.88,16.5 16.5,17.38 16.93,18.28C15.57,19.36 13.86,20 12,20C10.14,20 8.43,19.36 7.07,18.28M18.36,16.83C16.93,15.09 13.46,14.5 12,14.5C10.54,14.5 7.07,15.09 5.64,16.83C4.62,15.5 4,13.82 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,13.82 19.38,15.5 18.36,16.83M12,6C10.06,6 8.5,7.56 8.5,9.5C8.5,11.44 10.06,13 12,13C13.94,13 15.5,11.44 15.5,9.5C15.5,7.56 13.94,6 12,6M12,11A1.5,1.5 0 0,1 10.5,9.5A1.5,1.5 0 0,1 12,8A1.5,1.5 0 0,1 13.5,9.5A1.5,1.5 0 0,1 12,11Z"/>
                    </svg>
                    <input type="text" id="vatsimCallsign" placeholder="e.g., BAW123" maxlength="12">
                </div>
        
                <div id="flightPlanInfo" style="display: none;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; font-size: 0.85em; text-transform: uppercase; color: #888;">
                        <span data-i18n="runwaySelectLabel">Select Arrival Runway</span>
                    </label>
                    <select class="runway-select" id="runwaySelect">
                        <option value="" data-i18n="runwaySelectPlaceholder">Select runway...</option>
                    </select>
        
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; font-size: 0.85em; text-transform: uppercase; color: #888;">
                        <span data-i18n="approachSelectLabel">Select Approach (Optional)</span>
                    </label>
                    <div class="approach-chips" id="approachChips">
                        <div class="approach-chip auto" onclick="selectAutoApproach()">
                            <span data-i18n="autoRecommendChip">Auto-Recommend</span>
                        </div>
                    </div>
                    <p style="font-size: 0.8em; color: #888; margin-top: -10px;" data-i18n="approachOptionalText">
                        Leave as auto-recommend for best approach at 50nm
                    </p>
                </div>
        
                <div id="trackerMessage" class="tracker-message"></div>
        
                <!-- Action Buttons -->
                <div class="tracker-actions">
                    <button class="btn-start" id="startTrackingBtn" disabled onclick="startTracking()">
                        <span data-i18n="startTrackingBtn">üõ´ Start Tracking</span>
                    </button>
                    <button class="btn-stop" id="stopTrackingBtn" style="display: none;" onclick="stopTracking()">
                        <span data-i18n="stopTrackingBtn">üõë Stop Tracking</span>
                    </button>
                </div>
            </div>
        </div>
        <div class="image-box">
            <img src="box.png" alt="Box Decoration">
        </div>
    </div>
    <div class="settings-icon" onclick="openSettings()">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
        </svg>
    </div>
    <footer>
        pineapplecrazyav@gmail.com
    </footer>

    <script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>
    // Load airport data from JSON (single source of truth)
    let AIRPORT_DATA = {};
    let airportDataLoaded = false;
    let airportsInitialized = false;
    
    fetch('airports-data.json')
        .then(r => r.json())
        .then(data => { 
            AIRPORT_DATA = data;
            airportDataLoaded = true;
            console.log('Airport data loaded:', Object.keys(AIRPORT_DATA).length, 'airports');
            // Trigger initialization if DOM is ready
            if (document.readyState === 'complete' || document.readyState === 'interactive') {
                initializeAfterDataLoad();
            }
        })
        .catch(e => console.error('Failed to load airport data:', e));
    
    // Function to initialize UI elements after data loads
    function initializeAfterDataLoad() {
        if (airportsInitialized) return; // Prevent double initialization
        airportsInitialized = true;
        
        if (typeof loadAirports === 'function') {
            console.log('Initializing airports dropdown');
            loadAirports();
        }
        if (typeof loadAircraft === 'function') {
            console.log('Initializing aircraft dropdown');
            loadAircraft();
        }
    }
</script>

    <script>
        const translations = {
            en: {
                title: "Minima",
                selectAirport: "Select Airport",
                selectRunway: "Select Runway",
                selectAircraft: "Select Aircraft",
                selectApproach: "Select Approach",
                checkMinima: "Check Minima",
                required: "Required",
                actual: "Actual",
                headwind: "Headwind",
                tailwind: "Tailwind",
                crosswind: "Crosswind",
                windFrom: "Wind From",
                windSpeed: "Wind Speed",
                gusting: "Gusting",
                howItWorksTitle: "How it works:",
                howItWorksDesc1: "Check the status of any supported approach. We'll reference it to",
                currentWeatherConditions: "current weather conditions",
                howItWorksDesc2: "and your",
                aircraftCapabilities: "aircraft's capabilities",
                howItWorksDesc3: "to let you know if it's safe to fly.",
                howItWorksDesc4: "Put in an aerodrome, runway and aircraft, then press the wand - we'll",
                recommend: "recommend",
                howItWorksDesc5: "the approach we think best suited.",
                currentMetar: "Current METAR",
                metarStatus: "METAR Status",
                aboveMinima: "GO FOR IT!",
                belowMinima: "BELOW MINIMA",
                metarUnavailable: "METAR UNAVAILABLE",
                noWeatherData: "‚ö†Ô∏è No weather data",
                noWeatherMessage: "No METAR available - recommended approach has lowest visibility requirement",
                noCurrentWeather: "No current weather data is available for this aerodrome. You can still proceed with your flight planning, but verify actual weather conditions through other sources.",
                windVariable: "‚ö†Ô∏è Wind is variable - component calculations unavailable",
                errorRecommending: "Error recommending approach",
                vatsimTrackerTitle: "Live Tracking",
                vatsimTrackerInfoTitle: "Track Your Flight:",
                vatsimTrackerInfoDesc: "Enter your VATSIM callsign and runway. We'll monitor your position and send Discord alerts at 50nm and if weather deteriorates!",
                trackerStatusLabel: "Tracker Status",
                statusNotTracking: "NOT TRACKING",
                statusTracking: "TRACKING",
                statusMessageDefault: "Connect Discord and enter callsign to start tracking",
                infoCallsignLabel: "Callsign",
                infoDestinationLabel: "Destination",
                infoRunwayLabel: "Runway",
                infoApproachLabel: "Approach",
                infoSpeedLabel: "Speed",
                infoAircraftLabel: "Aircraft",
                distanceToDestLabel: "Distance to destination:",
                callsignInputLabel: "VATSIM Callsign",
                runwaySelectLabel: "Select Arrival Runway",
                runwaySelectPlaceholder: "Select runway...",
                approachSelectLabel: "Select Approach (Optional)",
                autoRecommendChip: "Auto-Recommend",
                approachOptionalText: "Leave as auto-recommend for best approach at 50nm",
                startTrackingBtn: "üõ´ Start Tracking",
                stopTrackingBtn: "üõë Stop Tracking",
                airports: {}
            },
            no: {
                title: "Minima",
                selectAirport: "Velg Flyplass",
                selectRunway: "Velg Rullebane",
                selectAircraft: "Velg Fly",
                selectApproach: "Velg Innflyging",
                checkMinima: "Sjekk Minima",
                required: "P√•krevd",
                actual: "Faktisk",
                headwind: "Motvind",
                tailwind: "Medvind",
                crosswind: "Sidevind",
                windFrom: "Vind fra",
                windSpeed: "Vindhastighet",
                gusting: "Vindkast",
                currentMetar: "Gjeldende METAR",
                metarStatus: "METAR-status",
                aboveMinima: "KLART FOR LANDING!",
                belowMinima: "UNDER MINIMA",
                metarUnavailable: "METAR IKKE TILGJENGELIG",
                noWeatherData: "‚ö†Ô∏è Ingen v√¶rdata",
                noWeatherMessage: "Ingen METAR tilgjengelig - anbefalt innflyging har laveste siktekrav",
                noCurrentWeather: "Ingen v√¶rdata er tilgjengelig for denne flyplassen. Du kan fortsette med flightplanleggingen, men verifiser faktiske v√¶rforhold gjennom andre kilder.",
                windVariable: "‚ö†Ô∏è Vinden er variabel - komponentberegninger ikke tilgjengelig",
                errorRecommending: "Feil ved anbefaling av innflyging",
                howItWorksTitle: "Slik fungerer det:",
                howItWorksDesc1: "Sjekk statusen til enhver st√∏ttet innflyging. Vi vil referere den til",
                currentWeatherConditions: "gjeldende v√¶rforhold",
                howItWorksDesc2: "og ditt",
                aircraftCapabilities: "flys kapasitet",
                howItWorksDesc3: "for √• la deg vite om det er trygt √• fly.",
                howItWorksDesc4: "Fyll inn en flyplass, rullebane og fly, deretter trykk p√• tryllestaven - vi vil",
                recommend: "anbefale",
                howItWorksDesc5: "innflygingen vi mener passer best.",
                vatsimTrackerTitle: "VATSIM Flysporin",
                vatsimTrackerInfoTitle: "‚úàÔ∏è Spor din flyging:",
                vatsimTrackerInfoDesc: "Skriv inn ditt VATSIM kallesignal og rullebane. Vi vil overv√•ke din posisjon og sende Discord-varsler p√• 50nm og hvis v√¶ret forverres!",
                trackerStatusLabel: "Sporingsstatus",
                statusNotTracking: "IKKE SPORING",
                statusTracking: "SPORING",
                statusMessageDefault: "Koble til Discord og skriv inn kallesignal for √• starte sporing",
                infoCallsignLabel: "Kallesignal",
                infoDestinationLabel: "Destinasjon",
                infoRunwayLabel: "Rullebane",
                infoApproachLabel: "Innflyging",
                infoSpeedLabel: "Hastighet",
                infoAircraftLabel: "Fly",
                distanceToDestLabel: "Avstand til destinasjon:",
                callsignInputLabel: "VATSIM Kallesignal",
                runwaySelectLabel: "Velg Ankomstrullebane",
                runwaySelectPlaceholder: "Velg rullebane...",
                approachSelectLabel: "Velg Innflyging (Valgfritt)",
                autoRecommendChip: "Auto-Anbefal",
                approachOptionalText: "La st√• som auto-anbefal for beste innflyging p√• 50nm",
                startTrackingBtn: "üõ´ Start Sporing",
                stopTrackingBtn: "üõë Stopp Sporing",
                airports: {
                    EBAW: "Antwerpen",
                    EBBR: "Brussel",
                    EBOS: "Oostende",
                    EDDK: "K√∏ln-Bonn",
                    EDDN: "N√ºrnberg",
                    EDDV: "Hannover",
                    EFET: "Enontekis",
                    EFHK: "Helsingfors",
                    EFKI: "Kajana",
                    EFLP: "Villmanstrand",
                    EFMA: "Mariehamn / √Öland",
                    EFOU: "Ule√•borg",
                    EFTP: "Tammerfors",
                    EFTU: "√Öbo",
                    EFVA: "Vasa",
                    EKCH: "K√∏benhavn",
                    ELLX: "Luxemburg",
                    EPMO: "Warsawa Modlin",
                    EPRA: "Warsawa Radom",
                    EPWA: "Warsawa Chopin",
                    ESGG: "G√∂teborg",
                    LIPH: "Venezia Treviso",
                    LIPZ: "Venezia Marco Polo",
                    LKPR: "Praha",
                    LOWW: "Wien",
                    LSGG: "Gen√®ve",
                }
            }
        };

        let currentLang = 'en';
        
        // Aircraft categories mapping
        const AIRCRAFT_MAP = {
            "A20N": "c", "A21N": "c", "A319": "c", "A320": "c", "A321": "c",
            "A332": "d", "A333": "d", "A338": "d", "A339": "d", "A343": "d",
            "A346": "d", "A359": "d", "A35K": "d", "A388": "d", "AT76": "b",
            "B38M": "c", "B39M": "c", "B737": "c", "B738": "c", "B739": "c",
            "B763": "d", "B764": "d", "B77F": "d", "B77L": "d", "B77W": "d",
            "B772": "d", "B788": "d", "B789": "d", "B78X": "d", "C172": "a",
            "C25B": "c", "C750": "c", "DA40": "a", "DA42": "a", "DH8D": "b",
            "E190": "c", "E175": "c", "MD11": "d", "MD82": "c", "PA28": "a",
            "TBM8": "b", "E170": "c", "E195": "c", "E290": "c", "E295": "c",
            "B350": "b", "PC21": "b", "BSC1": "c", "BSC3": "c"
        };

        function parseWindData(metar) {
            if (!metar) return { direction: null, speed: null, gust: null };
            
            const windPattern = /(\d{3}|VRB)(\d{2,3})(G(\d{2,3}))?KT/;
            const match = metar.match(windPattern);
            
            if (match) {
                const directionStr = match[1];
                const speed = parseInt(match[2]);
                const gust = match[4] ? parseInt(match[4]) : null;
                
                if (directionStr === "VRB") {
                    return { direction: null, speed, gust };
                }
                
                return { 
                    direction: parseInt(directionStr), 
                    speed, 
                    gust 
                };
            }
            
            return { direction: null, speed: null, gust: null };
        }

        function calculateWindComponents(windSpeed, windFromDirection, runwayHeading) {
            if (windFromDirection === null || windSpeed === null) {
                return { headwind: null, crosswind: null };
            }
            
            const angleDiff = windFromDirection - runwayHeading;
            const angleRad = (angleDiff * Math.PI) / 180;

            const headwind = windSpeed * Math.cos(angleRad);
            const crosswind = windSpeed * Math.sin(angleRad);
            
            return { headwind, crosswind };
        }

        function getRunwayHeading(runway) {
            const match = runway.match(/(\d{2})/);
            if (match) {
                return parseInt(match[1]) * 10;
            }
            return null;
        }

        function getVisibility(metar, runway) {
            if (!metar) return "N/A";

            if (metar.includes("CAVOK")) {
                return "9999";
            }

            // RVR (e.g. R27R/0600)
            const rw = runway.padStart(2, '0');
            const rvrPattern = new RegExp(`R${rw}[LCR]?/(\\d{4})`);
            const rvrMatch = metar.match(rvrPattern);
            if (rvrMatch) {
                return rvrMatch[1];
            }

            // Statute miles (e.g. 3SM)
            const smMatch = metar.match(/(\d+)SM/);
            if (smMatch) {
                return String(parseInt(smMatch[1]) * 1609);
            }

            // Plain visibility (e.g. 4000)
            const visMatch = metar.match(/\b(\d{4})\b/);
            if (visMatch) {
                return visMatch[1];
            }

            return "N/A";
        }

        async function fetchMETAR(icao) {
            const url = `https://metar.vatsim.net/${icao}`;
            try {
                const response = await fetch(url);
                if (response.ok) {
                    const metarText = await response.text();
                    if (metarText && metarText.trim() && !metarText.startsWith("No METAR")) {
                        return metarText;
                    }
                }
            } catch (error) {
                console.error('METAR fetch error:', error);
            }
            return null;
        }

        function loadAirportData(airport) {
            return AIRPORT_DATA[airport.toLowerCase()] || null;
        }

        // ============================================
        // CORE LOGIC
        // ============================================

        function calculateMinima(airport, runway, aircraft, approach) {
            airport = airport.toLowerCase();
            aircraft = aircraft.toUpperCase();

            const data = loadAirportData(airport);
            if (!data) return { error: "Unknown airport" };
            
            if (!AIRCRAFT_MAP[aircraft]) return { error: "Unknown aircraft" };

            const category = AIRCRAFT_MAP[aircraft];

            // Reconstruct the JSON key
            let key;
            if (approach.startsWith("rnp-")) {
                const suffix = approach.split("-")[1];
                key = suffix === "approach" ? `rnp${runway}` : `rnp${runway}-${suffix}`;
            } else {
                key = `${approach}${runway}`;
            }

            if (!data[key] || !data[key][category]) {
                return { error: `Minima not defined for ${key} (Cat ${category})` };
            }

            const val = data[key][category];
            const required = String(val).match(/^\d+$/) ? parseInt(val) : 0;

            return {
                airport: airport.toUpperCase(),
                runway,
                required,
                key,
                category
            };
        }

        async function checkMinimaWithWeather(airport, runway, aircraft, approach) {
            const minimaData = calculateMinima(airport, runway, aircraft, approach);
            
            if (minimaData.error) {
                return minimaData;
            }

            const metar = await fetchMETAR(airport.toUpperCase());
            
            if (metar === null) {
                return {
                    ...minimaData,
                    visibility: "N/A",
                    status: "METAR UNAVAILABLE",
                    metar: "No METAR data available for this aerodrome",
                    wind: null
                };
            }

            const visibility = getVisibility(metar, runway);
            const windParsed = parseWindData(metar);
            const runwayHeading = getRunwayHeading(runway);
            
            let windData = null;
            if (windParsed.direction !== null && windParsed.speed !== null && runwayHeading !== null) {
                const { headwind, crosswind } = calculateWindComponents(
                    windParsed.speed, 
                    windParsed.direction, 
                    runwayHeading
                );
                
                windData = {
                    direction: windParsed.direction,
                    speed: windParsed.speed,
                    gust: windParsed.gust,
                    headwind: Math.round(headwind * 10) / 10,
                    crosswind: Math.round(crosswind * 10) / 10,
                    variable: false
                };
            } else if (windParsed.speed !== null) {
                windData = {
                    direction: "VRB",
                    speed: windParsed.speed,
                    gust: windParsed.gust,
                    headwind: null,
                    crosswind: null,
                    variable: true
                };
            }

            let status;
            if (minimaData.required === 0) {
                status = "UNAVAILABLE";
            } else {
                status = "ABOVE MINIMA";
                if (visibility.match(/^\d+$/) && parseInt(visibility) < minimaData.required) {
                    status = "BELOW MINIMA";
                }
            }

            return {
                ...minimaData,
                visibility,
                status,
                metar,
                wind: windData
            };
        }

        async function recommendApproach(airport, runway, aircraft) {
            airport = airport.toLowerCase();
            runway = runway.toUpperCase();
            aircraft = aircraft.toUpperCase();

            const data = loadAirportData(airport);
            if (!data) return { error: "Unknown airport" };

            if (!AIRCRAFT_MAP[aircraft]) return { error: "Unknown aircraft" };

            const category = AIRCRAFT_MAP[aircraft];

            const ilsGls = [];
            const others = [];

            // Collect approaches
            for (const key in data) {
                console.log('Checking key:', key);
                if (!data[key][category]) continue;

                // RNP approaches
                const rnpMatch = key.match(new RegExp(`^rnp${runway}(?:-(.+))?$`));
                if (rnpMatch) {
                    const suffix = rnpMatch[1] || "approach";
                    others.push(`rnp-${suffix.toLowerCase()}`);
                    continue;
                }

                // ILS / GLS
                if ((key.startsWith("il") || key.startsWith("gl")) && key.endsWith(runway)) {
                    const prefix = key.slice(0, -runway.length);
                    ilsGls.push(prefix);
                } else if (key.endsWith(runway)) {
                    const prefix = key.slice(0, -runway.length);
                    others.push(prefix);
                }
            }

            if (ilsGls.length === 0 && others.length === 0) {
                return { error: "No approaches available for this runway" };
            }

            // Test if METAR is available
            const testPrefix = ilsGls.length > 0 ? ilsGls[0] : others[0];
            const testResult = await checkMinimaWithWeather(airport, runway, aircraft, testPrefix);
            
            const metarUnavailable = testResult.status === "METAR UNAVAILABLE";

            // If METAR unavailable, recommend lowest requirement
            if (metarUnavailable) {
                const allApproaches = [];
                
                const catRank = (prefix) => {
                    if (prefix.startsWith("il")) return parseInt(prefix[2]);
                    if (prefix.startsWith("gl")) return parseInt(prefix[3]);
                    return 999;
                };
                
                for (const prefix of ilsGls) {
                    const result = calculateMinima(airport, runway, aircraft, prefix);
                    if (result.required > 0) {
                        allApproaches.push([catRank(prefix), result.required, prefix]);
                    }
                }
                
                for (const prefix of others) {
                    const result = calculateMinima(airport, runway, aircraft, prefix);
                    if (result.required > 0) {
                        allApproaches.push([999, result.required, prefix]);
                    }
                }
                
                if (allApproaches.length > 0) {
                    allApproaches.sort((a, b) => a[0] - b[0] || a[1] - b[1]);
                    return {
                        recommended: allApproaches[0][2],
                        metar_unavailable: true,
                        message: "No METAR available - recommended approach has lowest visibility requirement"
                    };
                }
                
                return { error: "No approaches available with defined minima" };
            }

            // ILS / GLS logic (CAT I ‚Üí CAT III)
            if (ilsGls.length > 0) {
                const catRank = (p) => {
                    if (p.startsWith("il")) return parseInt(p[2]);
                    if (p.startsWith("gl")) return parseInt(p[3]);
                    return 9;
                };

                ilsGls.sort((a, b) => catRank(a) - catRank(b));

                for (const prefix of ilsGls) {
                    const result = await checkMinimaWithWeather(airport, runway, aircraft, prefix);
                    if (result.status === "ABOVE MINIMA") {
                        return { recommended: prefix };
                    }
                }
            }

            // No ILS/GLS ‚Üí lowest RVR requirement wins
            const candidates = [];

            for (const prefix of others) {
                const result = await checkMinimaWithWeather(airport, runway, aircraft, prefix);
                
                if (result.status !== "ABOVE MINIMA") continue;
                if (!result.required || result.required <= 0) continue;
                
                candidates.push([result.required, prefix]);
            }

            if (candidates.length > 0) {
                candidates.sort((a, b) => a[0] - b[0]);
                return { recommended: candidates[0][1] };
            }

            return { error: "No suitable approach above minima" };
        }

        // ============================================
        // TRANSLATION FUNCTIONS
        // ============================================

        function translate() {
            const t = translations[currentLang];
            console.log('Translating to:', currentLang);
            
            // Update all elements with data-i18n attribute
            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                if (t[key]) {
                    element.textContent = t[key];
                    console.log('Updated', key, 'to', t[key]);
                }
            });
            
            // Reload dropdowns to update airport names
            if (airportSel.options.length > 0) {
                console.log('Reloading airports');
                loadAirports();
            }
            if (aircraftSel.options.length > 0) {
                console.log('Reloading aircraft');
                loadAircraft();
            }
            
            // Update placeholder options
            updateDropdownPlaceholders();
        }

        function updateDropdownPlaceholders() {
            const t = translations[currentLang];
            if (airportSel.options[0]) airportSel.options[0].textContent = t.selectAirport;
            if (runwaySel.options[0]) runwaySel.options[0].textContent = t.selectRunway;
            if (aircraftSel.options[0]) aircraftSel.options[0].textContent = t.selectAircraft;
            if (approachSel.options[0]) approachSel.options[0].textContent = t.selectApproach;
        }

        function getTranslatedAirportName(code) {
            const t = translations[currentLang];
            const upperCode = code.toUpperCase();
            if (t.airports && t.airports[upperCode]) {
                return t.airports[upperCode];
            }
            // Fallback to data if not in translations
            if (AIRPORT_DATA[code] && AIRPORT_DATA[code].name) {
                return AIRPORT_DATA[code].name;
            }
            return "";
        }

        // ============================================
        // UI FUNCTIONS
        // ============================================

        const airportSel = document.getElementById('airport');
        const aircraftSel = document.getElementById('aircraft');
        const runwaySel = document.getElementById('runway');
        const approachSel = document.getElementById('approach');
        const checkBtn = document.getElementById('checkBtn');
        const magicWand = document.getElementById('magicWand');
        const resultDiv = document.getElementById('result');

        function loadAirports() {
            const t = translations[currentLang];
            const currentValue = airportSel.value;
            airportSel.innerHTML = `<option value="">${t.selectAirport}</option>`;
            const airports = Object.keys(AIRPORT_DATA).map(code => ({
                code: code.toUpperCase(),
                name: getTranslatedAirportName(code)
            }));
            airports.sort((a, b) => a.code.localeCompare(b.code));
            airports.forEach(ap => {
                const option = new Option(`${ap.code}${ap.name ? ' - ' + ap.name : ''}`, ap.code);
                airportSel.add(option);
            });
            airportSel.value = currentValue;
        }

        function loadAircraft() {
            const t = translations[currentLang];
            const currentValue = aircraftSel.value;
            aircraftSel.innerHTML = `<option value="">${t.selectAircraft}</option>`;
            const aircraft = Object.keys(AIRCRAFT_MAP).sort();
            aircraft.forEach(ac => aircraftSel.add(new Option(ac, ac)));
            aircraftSel.value = currentValue;
        }

        function loadRunways() {
            const t = translations[currentLang];
            approachSel.innerHTML = `<option value="">${t.selectApproach}</option>`;
            approachSel.disabled = true;
            runwaySel.value = "";
            runwaySel.disabled = true;
            runwaySel.innerHTML = '<option value="">Loading...</option>';
            
            if (!airportSel.value) return;

            const data = loadAirportData(airportSel.value);
            if (!data) {
                runwaySel.innerHTML = '<option value="">No data</option>';
                return;
            }

            const runways = new Set();

            for (const key in data) {
                const match = key.match(/(\d{2}[LRC]?)(?:-[a-z0-9]+)?$/);
                if (match) {
                    runways.add(match[1]);
                }
            }

            runwaySel.innerHTML = `<option value="">${t.selectRunway}</option>`;
            Array.from(runways).sort().forEach(rw => runwaySel.add(new Option(rw, rw)));
            runwaySel.disabled = false;
            updateUI();
        }

        function loadApproaches() {
            const t = translations[currentLang];
            if (!aircraftSel.value) {
                approachSel.innerHTML = `<option value="">${t.selectAircraft}</option>`;
                return;
            }

            approachSel.disabled = true;
            approachSel.innerHTML = '<option value="">Loading...</option>';

            const airport = airportSel.value.toLowerCase();
            const runway = runwaySel.value.toUpperCase();
            const aircraft = aircraftSel.value.toUpperCase();

            const data = loadAirportData(airport);
            if (!data || !runway) {
                approachSel.innerHTML = '<option value="">No data</option>';
                return;
            }

            const category = AIRCRAFT_MAP[aircraft];
            const approaches = [];

            for (const key in data) {
                const minima = data[key];

                // RNP approaches
                const rnpMatch = key.match(new RegExp(`^rnp${runway}(?:-(.+))?$`));
                if (rnpMatch) {
                    const suffix = rnpMatch[1] || "approach";
                    approaches.push({
                        type: "RNP",
                        label: `RNP ${suffix.toUpperCase()}`,
                        value: `rnp-${suffix.toLowerCase()}`,
                        required: category ? minima[category] : null
                    });
                    continue;
                }

                // ILS / GLS / others
                const match = key.match(/^([a-z]{2,4}[123]?)(\d{2}[LRC]?)$/);
                if (!match || match[2] !== runway) continue;

                const prefix = match[1];
                let label, type;

                if (prefix.startsWith("il")) {
                    label = `ILS CAT ${prefix[2]}`;
                    type = "ILS";
                } else if (prefix.startsWith("gl")) {
                    label = `GLS CAT ${prefix[prefix.length - 1]}`;
                    type = "GLS";
                } else if (prefix.toLowerCase().startsWith("crc")) {
                    label = "CIRCLING";
                    type = "CIRCLING";
                 } else if (prefix.toLowerCase().startsWith("lcr")) {
                    label = "LCTR";
                    type = "LCTR";
                } else if (prefix.toLowerCase().startsWith("vis")) {
                    label = "VISUAL";
                    type = "VISUAL";
                } else {
                    label = prefix.toUpperCase();
                    type = label;
                }

                approaches.push({
                    type,
                    label,
                    value: prefix,
                    required: category ? minima[category] : null
                });
            }

            approachSel.innerHTML = `<option value="">${t.selectApproach}</option>`;
            approaches.forEach(ap => approachSel.add(new Option(ap.label, ap.value)));

            approachSel.disabled = false;
            updateUI();
        }

        function updateUI() {
            const allSelected = airportSel.value && runwaySel.value && aircraftSel.value && approachSel.value;
            checkBtn.disabled = !allSelected;

            const canRecommend = airportSel.value && runwaySel.value && aircraftSel.value && approachSel.options.length > 1;
            magicWand.style.display = canRecommend ? "flex" : "none";
        }

        async function onRecommendApproach() {
            const t = translations[currentLang];
            if (magicWand.classList.contains("loading")) return;

            magicWand.classList.add("loading");

            try {
                const data = await recommendApproach(
                    airportSel.value,
                    runwaySel.value,
                    aircraftSel.value
                );

                if (data.recommended) {
                    approachSel.value = data.recommended;
                    updateUI();
                    
                    if (data.metar_unavailable) {
                        resultDiv.className = "result show warning";
                        resultDiv.innerHTML = `
                            <p style="font-size: 1.1em; margin-top:0;"><strong>${t.noWeatherData}</strong></p>
                            <p style="margin: 10px 0;">${data.message || t.noWeatherMessage}</p>
                        `;
                    }
                } else if (data.error) {
                    alert("Error: " + data.error);
                }
            } catch (e) {
                console.error(e);
                alert(t.errorRecommending);
            } finally {
                magicWand.classList.remove("loading");
            }
        }

        function formatWindComponents(wind) {
            const t = translations[currentLang];
            if (!wind) return '';
            
            if (wind.variable) {
                let windText = `<div class="wind-components">
                    <div class="wind-item">
                        <span class="wind-label">${t.windSpeed}</span>
                        <span class="wind-value">VRB ${wind.speed}kt</span>
                    </div>`;
                
                if (wind.gust) {
                    windText += `
                    <div class="wind-item">
                        <span class="wind-label">${t.gusting}</span>
                        <span class="wind-value">${wind.gust}kt</span>
                    </div>`;
                }
                
                windText += `</div>
                    <p style="font-size: 0.85em; color: #ffa726; margin: 10px 0;">${t.windVariable}</p>`;
                return windText;
            }
            
            let html = '<div class="wind-components">';
            
            // Headwind/Tailwind
            const hw = wind.headwind;
            if (hw >= 0) {
                html += `
                    <div class="wind-item">
                        <span class="wind-label">${t.headwind}</span>
                        <span class="wind-value headwind">${Math.abs(hw).toFixed(1)}kt</span>
                    </div>`;
            } else {
                html += `
                    <div class="wind-item">
                        <span class="wind-label">${t.tailwind}</span>
                        <span class="wind-value tailwind">${Math.abs(hw).toFixed(1)}kt</span>
                    </div>`;
            }
            
            // Crosswind
            const xw = wind.crosswind;
            const xwDir = xw > 0 ? 'Right' : xw < 0 ? 'Left' : '';
            html += `
                <div class="wind-item">
                    <span class="wind-label">${t.crosswind} ${xwDir}</span>
                    <span class="wind-value crosswind">${Math.abs(xw).toFixed(1)}kt</span>
                </div>`;
            
            // Wind direction and speed
            html += `
                <div class="wind-item">
                    <span class="wind-label">${t.windFrom}</span>
                    <span class="wind-value">${wind.direction}¬∞</span>
                </div>`;
            
            html += `
                <div class="wind-item">
                    <span class="wind-label">${t.windSpeed}</span>
                    <span class="wind-value">${wind.speed}kt</span>
                </div>`;
            
            html += '</div>';
            
            if (wind.gust) {
                html += `<p style="font-size: 0.85em; color: #ffa726; margin: 10px 0;">${t.gusting} ${wind.gust}kt</p>`;
            }
            
            return html;
        }

        async function onCheckMinima() {
            const t = translations[currentLang];
            resultDiv.innerHTML = "Fetching weather...";
            resultDiv.className = "result show neutral";

            const data = await checkMinimaWithWeather(
                airportSel.value,
                runwaySel.value,
                aircraftSel.value,
                approachSel.value
            );

            if (data.error) {
                resultDiv.innerHTML = `<p style="color:var(--error)">${data.error}</p>`;
                return;
            }

            let colorClass = "neutral";
            if (data.status.includes("BELOW")) colorClass = "red";
            if (data.status.includes("ABOVE")) colorClass = "green";
            if (data.status === "UNAVAILABLE") colorClass = "neutral";
            if (data.status === "METAR UNAVAILABLE") colorClass = "warning";

            resultDiv.className = `result show ${colorClass}`;
            
            if (data.status === "METAR UNAVAILABLE") {
                resultDiv.innerHTML = `
                    <p style="font-size: 1.2em; margin-top:0;"><strong>${t.metarUnavailable}</strong></p>
                    <p style="margin: 10px 0;">${t.noCurrentWeather}</p>
                    <div style="margin-top: 15px;">
                        <span>${t.required}: <strong>${data.required}m</strong></span>
                    </div>
                    <label style="margin-top: 15px;">${t.metarStatus}</label>
                    <pre>${data.metar}</pre>
                `;
            } else {
                const displayStatus = data.status === "ABOVE MINIMA" ? t.aboveMinima : t.belowMinima;
                
                resultDiv.innerHTML = `
                    <p style="font-size: 1.2em; margin-top:0;"><strong>${displayStatus}</strong></p>
                    <div class="visibility-box">
                        <div class="visibility-item">
                            <span class="visibility-label">${t.required}</span>
                            <span class="visibility-value">${data.required}m</span>
                        </div>
                        <div class="visibility-item">
                            <span class="visibility-label">${t.actual}</span>
                            <span class="visibility-value">${data.visibility}m</span>
                        </div>
                    </div>
                    ${formatWindComponents(data.wind)}
                    <label>${t.currentMetar}</label>
                    <pre>${data.metar}</pre>
                `;
            }
        }

        // Event listeners
        airportSel.addEventListener('change', loadRunways);
        runwaySel.addEventListener('change', loadApproaches);
        aircraftSel.addEventListener('change', () => {
            if (runwaySel.value) loadApproaches();
        });
        approachSel.addEventListener('change', updateUI);
        checkBtn.addEventListener('click', onCheckMinima);
        magicWand.addEventListener('click', onRecommendApproach);

        // Language dropdown event listener
        document.getElementById('langSelect').addEventListener('change', function() {
            console.log('Language dropdown changed from', currentLang, 'to', this.value);
            currentLang = this.value;
            translate();
            localStorage.setItem('language', currentLang);
        });

        // Load saved language preference and initialize
        window.addEventListener('DOMContentLoaded', () => {
            const savedLang = localStorage.getItem('language') || 'en';
            currentLang = savedLang;
            document.getElementById('langSelect').value = currentLang;
            
            // Wait for airport data before initializing
            const checkDataLoaded = setInterval(() => {
                if (airportDataLoaded) {
                    clearInterval(checkDataLoaded);
                    initializeAfterDataLoad();
                    translate();
                    updateUI();
                }
            }, 50); // Check every 50ms
            
            // Timeout after 5 seconds
            setTimeout(() => {
                clearInterval(checkDataLoaded);
                if (!airportDataLoaded) {
                    console.error('Airport data failed to load within 5 seconds');
                    translate();
                    updateUI();
                }
            }, 5000);
        });
    </script>
    <div class="settings-modal" id="settingsModal">
        <div class="settings-content">
            <div class="settings-header">
                <h2>Settings</h2>
                <button class="close-btn" onclick="closeSettings()">&times;</button>
            </div>

            <!-- Discord Section -->
            <div class="discord-section">
                <h3 style="margin-top: 0;">Discord Integration</h3>
                
                <!-- Not Connected State -->
                <div id="discordNotConnected" style="display: none;">
                    <div class="discord-status">
                        <span class="status-indicator"></span>
                        <span>Not Connected</span>
                    </div>
                    <p style="font-size: 0.9em; color: #aaa;">
                        Connect your Discord account to receive real-time weather alerts and notifications.
                    </p>
                    <button class="settings-btn" onclick="connectDiscord()">
                        Connect Discord
                    </button>
                </div>

                <!-- Connected State -->
                <div id="discordConnected" style="display: none;">
                    <div class="discord-status">
                        <span class="status-indicator connected"></span>
                        <span>Connected</span>
                    </div>
                    
                    <div class="discord-info">
                        <img id="discordAvatar" class="discord-avatar" src="" alt="Avatar">
                        <div>
                            <strong id="discordUsername"></strong>
                            <div style="font-size: 0.85em; color: #888;">Discord Account</div>
                        </div>
                    </div>

                    <div class="notification-toggle">
                        <span>Enable Notifications</span>
                        <div class="toggle-switch" id="notificationToggle" onclick="toggleNotifications()">
                            <div class="toggle-slider"></div>
                        </div>
                    </div>

                    <button class="settings-btn secondary" onclick="sendTestDM()">
                        Send Test Message
                    </button>
                    
                    <button class="settings-btn danger" onclick="disconnectDiscord()">
                        Disconnect Discord
                    </button>
                </div>
            </div>
        </div>
    </div>
    <script>
        const API_URL = 'https://minima-discord-backend-production.up.railway.app';
        
        // Discord connection state
        let discordUser = null;
        let notificationsEnabled = true;
        let sessionToken = null;
        
        // Get session token from localStorage
        function getSessionToken() {
            return localStorage.getItem('minima_session_token');
        }
        
        // Save session token to localStorage
        function saveSessionToken(token) {
            localStorage.setItem('minima_session_token', token);
            sessionToken = token;
        }
        
        // Clear session token
        function clearSessionToken() {
            localStorage.removeItem('minima_session_token');
            sessionToken = null;
        }
        
        // Add token to fetch requests
        function fetchWithAuth(url, options = {}) {
            const token = getSessionToken();
            
            if (token) {
                options.headers = {
                    ...options.headers,
                    'X-Session-Token': token
                };
            }
            
            options.credentials = 'include';
            
            return fetch(url, options);
        }
        
        // Check if user is authenticated on page load
        window.addEventListener('DOMContentLoaded', () => {
            checkAuthStatus();
            
            // Check if redirected from Discord OAuth
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('auth') === 'success') {
                const username = urlParams.get('user');
                const token = urlParams.get('token');
                
                // Save token to localStorage
                if (token) {
                    saveSessionToken(token);
                    console.log('Session token saved!');
                }
                
                alert(`Successfully connected to Discord! Welcome, ${username}!`);
                
                // Clean URL
                window.history.replaceState({}, document.title, window.location.pathname);
                
                checkAuthStatus();
            }
        });
        
        async function checkAuthStatus() {
            try {
                const response = await fetchWithAuth(`${API_URL}/api/user/me`);
                
                if (response.ok) {
                    discordUser = await response.json();
                    console.log('User authenticated:', discordUser.username);
                    updateDiscordUI(true);
                } else {
                    console.log('Not authenticated, clearing token');
                    clearSessionToken();
                    updateDiscordUI(false);
                }
            } catch (error) {
                console.error('Error checking auth status:', error);
                clearSessionToken();
                updateDiscordUI(false);
            }
        }
        
        function updateDiscordUI(connected) {
            const connectedDiv = document.getElementById('discordConnected');
            const notConnectedDiv = document.getElementById('discordNotConnected');
            
            if (connected && discordUser) {
                connectedDiv.style.display = 'block';
                notConnectedDiv.style.display = 'none';
                
                document.getElementById('discordUsername').textContent = discordUser.username;
                
                // Set avatar
                if (discordUser.avatar) {
                    const avatarUrl = `https://cdn.discordapp.com/avatars/${discordUser.discord_id}/${discordUser.avatar}.png`;
                    document.getElementById('discordAvatar').src = avatarUrl;
                } else {
                    document.getElementById('discordAvatar').src = 'https://cdn.discordapp.com/embed/avatars/0.png';
                }
                
                // Update notification toggle
                notificationsEnabled = discordUser.notifications_enabled;
                const toggle = document.getElementById('notificationToggle');
                if (notificationsEnabled) {
                    toggle.classList.add('active');
                } else {
                    toggle.classList.remove('active');
                }
            } else {
                connectedDiv.style.display = 'none';
                notConnectedDiv.style.display = 'block';
            }
        }
        
        async function connectDiscord() {
            try {
                const response = await fetch(`${API_URL}/api/discord/auth-url`);
                const data = await response.json();
                
                if (data.auth_url) {
                    window.location.href = data.auth_url;
                }
            } catch (error) {
                console.error('Error getting Discord auth URL:', error);
                alert('Failed to connect to Discord. Please try again.');
            }
        }
        
        async function disconnectDiscord() {
            if (!confirm('Are you sure you want to disconnect your Discord account?')) {
                return;
            }
            
            try {
                const response = await fetchWithAuth(`${API_URL}/api/user/disconnect`, {
                    method: 'POST'
                });
                
                if (response.ok) {
                    discordUser = null;
                    clearSessionToken();
                    updateDiscordUI(false);
                    alert('Discord account disconnected successfully.');
                }
            } catch (error) {
                console.error('Error disconnecting Discord:', error);
                alert('Failed to disconnect. Please try again.');
            }
        }
        
        async function toggleNotifications() {
            if (!discordUser) return;
            
            notificationsEnabled = !notificationsEnabled;
            const toggle = document.getElementById('notificationToggle');
            
            if (notificationsEnabled) {
                toggle.classList.add('active');
            } else {
                toggle.classList.remove('active');
            }
            
            try {
                await fetchWithAuth(`${API_URL}/api/user/notifications/toggle`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled: notificationsEnabled })
                });
            } catch (error) {
                console.error('Error toggling notifications:', error);
            }
        }
        
        async function sendTestDM() {
            try {
                const response = await fetchWithAuth(`${API_URL}/api/discord/test-dm`, {
                    method: 'POST'
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    alert('Test message sent! Check your Discord DMs.');
                } else {
                    alert(data.error || 'Failed to send test message.');
                }
            } catch (error) {
                console.error('Error sending test DM:', error);
                alert('Failed to send test message. Please try again.');
            }
        }
        
        function openSettings() {
            document.getElementById('settingsModal').classList.add('show');
        }
        
        function closeSettings() {
            document.getElementById('settingsModal').classList.remove('show');
        }
        
        // Close modal when clicking outside
        document.getElementById('settingsModal').addEventListener('click', (e) => {
            if (e.target.id === 'settingsModal') {
                closeSettings();
            }
        });
    </script>

<script>
let trackedFlight = null;
let updateInterval = null;
let selectedRunway = null;
let selectedApproach = null;
let autoRecommend = true;
let flightPlanData = null;

// Initialize tracker on page load
document.addEventListener('DOMContentLoaded', () => {
    const callsignInput = document.getElementById('vatsimCallsign');
    
    callsignInput.addEventListener('input', (e) => {
        e.target.value = e.target.value.toUpperCase().trim();
    });
    
    callsignInput.addEventListener('blur', fetchFlightPlan);
    
    const runwaySelect = document.getElementById('runwaySelect');
    runwaySelect.addEventListener('change', onRunwayChange);
    
    // Check if already tracking
    checkExistingTracking();
});

async function fetchFlightPlan() {
    const callsign = document.getElementById('vatsimCallsign').value.trim();
    if (!callsign) {
        document.getElementById('flightPlanInfo').style.display = 'none';
        return;
    }
    
    showTrackerMessage('loading', 'Fetching flight plan from VATSIM...');
    
    try {
        const response = await fetchWithAuth(`${API_URL}/api/vatsim/flight/${callsign}`);
        const data = await response.json();
        
        if (data.found && data.flight_plan && data.flight_plan.arrival) {
            flightPlanData = data;
            const destination = data.flight_plan.arrival;
            const aircraft = data.flight_plan.aircraft_short;
            
            showTrackerMessage('success', `‚úàÔ∏è Flight found! Flying to ${destination} in ${aircraft}`);
            
            // Load runways for destination
            await loadRunwaysForAirport(destination, aircraft);
            
            document.getElementById('flightPlanInfo').style.display = 'block';
            checkTrackingRequirements();
        } else {
            showTrackerMessage('error', 'Flight not found on VATSIM. Make sure you\'re connected with a filed flight plan.');
            document.getElementById('flightPlanInfo').style.display = 'none';
        }
    } catch (error) {
        console.error('Error fetching flight plan:', error);
        showTrackerMessage('error', 'Error connecting to VATSIM. Please try again.');
    }
}

async function loadRunwaysForAirport(airport, aircraft) {
    try {
        airport = airport.toLowerCase();
        
        // Check if airport exists in frontend data
        if (!AIRPORT_DATA[airport]) {
            showTrackerMessage('error', `No runway data available for ${airport.toUpperCase()}`);
            return;
        }
        
        // Extract unique runways from approach names
        const runways = new Set();
        const airportData = AIRPORT_DATA[airport];
        
        Object.keys(airportData).forEach(key => {
            if (key === 'name') return;
            
            // Extract runway from END of string (handles IL207R correctly as 07R, not 20)
            const match = key.match(/(\d{2}[LRC]?)(?:-[a-z0-9]+)?$/);
            if (match) {
                runways.add(match[1].toUpperCase());
            }
        });
        
        // Populate runway dropdown
        const runwaySelect = document.getElementById('runwaySelect');
        runwaySelect.innerHTML = '<option value="">Select runway...</option>';
        
        Array.from(runways).sort().forEach(rwy => {
            const option = document.createElement('option');
            option.value = rwy;
            option.textContent = `Runway ${rwy}`;
            runwaySelect.appendChild(option);
        });
        
        if (runways.size === 0) {
            showTrackerMessage('error', `No runways found for ${airport.toUpperCase()}`);
        }
        
    } catch (error) {
        console.error('Error loading runways:', error);
        showTrackerMessage('error', 'Error loading runway data');
    }
}

async function onRunwayChange() {
    const runway = document.getElementById('runwaySelect').value;
    selectedRunway = runway;
    
    if (!runway || !flightPlanData) {
        document.getElementById('approachChips').innerHTML = `
            <div class="approach-chip auto selected" onclick="selectAutoApproach()">
                Auto-Recommend
            </div>
        `;
        autoRecommend = true;
        checkTrackingRequirements();
        return;
    }
    
    // Load approaches for this runway from frontend data
    const airport = flightPlanData.flight_plan.arrival.toLowerCase();
    const aircraft = flightPlanData.flight_plan.aircraft_short;
    
    if (!AIRPORT_DATA[airport]) {
        showApproachChips([]);
        return;
    }
    
    const airportData = AIRPORT_DATA[airport];
    const approaches = [];
    const category = AIRCRAFT_MAP[aircraft] || 'c';
    
    // Find approaches for this runway
    Object.keys(airportData).forEach(key => {
        if (key === 'name') return;
        
        // Match approaches using the same pattern as original code
        // RNP approaches
        const rnpMatch = key.match(new RegExp(`^rnp${runway}(?:-(.+))?$`, 'i'));
        if (rnpMatch) {
            const minima = airportData[key];
            if (minima[category] && minima[category] !== "0") {
                const suffix = rnpMatch[1] || "approach";
                approaches.push({
                    id: key,
                    label: `RNP ${suffix.toUpperCase()} ${runway}`,
                    type: key,
                    runway: runway
                });
            }
            return;
        }
        
        // ILS / GLS / VOR / others
        const match = key.match(/^([a-z]{2,4}[123]?)(\d{2}[LRC]?)$/i);
        if (!match || match[2].toUpperCase() !== runway.toUpperCase()) return;
        
        const minima = airportData[key];
        if (!minima[category] || minima[category] === "0") return;
        
        const prefix = match[1].toLowerCase();
        let label;
        
        if (prefix.startsWith("il")) {
            label = `ILS CAT ${prefix[2]}`;
        } else if (prefix.startsWith("gl")) {
            label = `GLS CAT ${prefix[prefix.length - 1]}`;
        } else {
            label = prefix.toUpperCase();
        }
        
        approaches.push({
            id: key,
            label: `${label} ${runway}`,
            type: key,
            runway: runway
        });
    });
    
    showApproachChips(approaches);
    
    if (approaches.length === 0) {
        showTrackerMessage('info', `No approaches available for runway ${runway} with your aircraft`);
    }
    checkTrackingRequirements();
}

function showApproachChips(approaches) {
    const container = document.getElementById('approachChips');
    
    let html = `
        <div class="approach-chip auto selected" onclick="selectAutoApproach()">
            Auto-Recommend
        </div>
    `;
    
    approaches.forEach(app => {
        html += `
            <div class="approach-chip" onclick="selectApproach('${app.type}', '${app.label}')">
                ${app.label}
            </div>
        `;
    });
    
    container.innerHTML = html;
    autoRecommend = true;
    selectedApproach = null;
}

function selectAutoApproach() {
    document.querySelectorAll('.approach-chip').forEach(chip => {
        chip.classList.remove('selected');
    });
    event.target.classList.add('selected');
    
    autoRecommend = true;
    selectedApproach = null;
    checkTrackingRequirements();
}

function selectApproach(type, label) {
    document.querySelectorAll('.approach-chip').forEach(chip => {
        chip.classList.remove('selected');
    });
    event.target.classList.add('selected');
    
    autoRecommend = false;
    selectedApproach = { type, label };
    checkTrackingRequirements();
}

function checkTrackingRequirements() {
    const callsign = document.getElementById('vatsimCallsign').value.trim();
    const runway = selectedRunway;
    
    window.trackingReady = {
        hasCallsign: callsign.length > 0,
        hasDiscord: discordUser !== null,
        hasFlightPlan: flightPlanData !== null,
        hasRunway: runway && runway.length > 0
    };
    
    const startBtn = document.getElementById('startTrackingBtn');
    startBtn.disabled = false;
}

async function startTracking() {
    const callsign = document.getElementById('vatsimCallsign').value.trim();
    
    // Check requirements and show helpful errors
    if (!callsign) {
        showTrackerMessage('error', 'Please enter your VATSIM callsign!');
        document.getElementById('vatsimCallsign').focus();
        return;
    }
    
    if (!discordUser) {
        showTrackerMessage('error', 'Please connect your Discord account first!');
        openSettings();
        return;
    }
    
    if (!flightPlanData) {
        showTrackerMessage('error', 'Loading flight plan... Please wait.');
        return;
    }
    
    if (!selectedRunway) {
        showTrackerMessage('error', 'Please select a runway first!');
        return;
    }
    
    // All requirements met - start tracking!
    try {
        showTrackerMessage('loading', 'Starting tracking...');
        
        const response = await fetchWithAuth(`${API_URL}/api/vatsim/track/start`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                callsign: callsign,
                runway: selectedRunway,
                approach_type: selectedApproach ? selectedApproach.type : null,
                auto_recommend: autoRecommend
            })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            trackedFlight = data.tracking;
            showTrackerMessage('success', `üõ´ Now tracking ${callsign}! You'll receive Discord alerts at 50nm and if weather deteriorates.`);
            updateTrackerUI(true);
            startLiveUpdates();
        } else {
            showTrackerMessage('error', data.error || 'Failed to start tracking');
        }
    } catch (error) {
        console.error('Error starting tracking:', error);
        showTrackerMessage('error', 'Error starting tracking. Please try again.');
    }
}

async function stopTracking() {
    if (!confirm('Are you sure you want to stop tracking this flight?')) {
        return;
    }
    
    try {
        const response = await fetchWithAuth(`${API_URL}/api/vatsim/track/stop`, {
            method: 'POST'
        });
        
        if (response.ok) {
            trackedFlight = null;
            updateTrackerUI(false);
            stopLiveUpdates();
            showTrackerMessage('info', 'Tracking stopped.');
            
            // Reset form
            document.getElementById('vatsimCallsign').value = '';
            document.getElementById('flightPlanInfo').style.display = 'none';
        }
    } catch (error) {
        console.error('Error stopping tracking:', error);
    }
}

async function checkExistingTracking() {
    try {
        const response = await fetchWithAuth(`${API_URL}/api/vatsim/track/status`);
        
        if (response.ok) {
            const data = await response.json();
            if (data.tracking) {
                trackedFlight = data.tracking;
                updateTrackerUI(true);
                startLiveUpdates();
                
                // Pre-fill form
                document.getElementById('vatsimCallsign').value = data.tracking.callsign;
                document.getElementById('vatsimCallsign').disabled = true;
            }
        }
    } catch (error) {
        console.error('Error checking tracking status:', error);
    }
}

function updateTrackerUI(isTracking) {
    const statusBadge = document.getElementById('statusBadge');
    const statusMessage = document.getElementById('statusMessage');
    const flightInfo = document.getElementById('flightInfo');
    const trackerStatus = document.getElementById('trackerStatus');
    const startBtn = document.getElementById('startTrackingBtn');
    const stopBtn = document.getElementById('stopTrackingBtn');
    const trackerForm = document.getElementById('trackerForm');
    
    if (isTracking && trackedFlight) {
        statusBadge.textContent = 'TRACKING';
        statusBadge.classList.remove('inactive');
        statusBadge.classList.add('tracking');
        statusMessage.textContent = `Monitoring ${trackedFlight.callsign} - Will alert at 50nm and if weather deteriorates`;
        trackerStatus.classList.add('active');
        flightInfo.style.display = 'block';
        startBtn.style.display = 'none';
        stopBtn.style.display = 'block';
        trackerForm.style.opacity = '0.5';
        trackerForm.style.pointerEvents = 'none';
        
        // Update flight info
        document.getElementById('infoCallsign').textContent = trackedFlight.callsign;
        document.getElementById('infoDestination').textContent = trackedFlight.destination_airport;
        document.getElementById('infoRunway').textContent = trackedFlight.runway;
        
        const approachText = trackedFlight.auto_recommend 
            ? 'Auto' 
            : `${trackedFlight.approach_type?.toUpperCase() || '‚Äî'}`;
        document.getElementById('infoApproach').textContent = approachText;
        
        document.getElementById('infoSpeed').textContent = trackedFlight.current_speed ? `${trackedFlight.current_speed}kts` : '‚Äî';
        document.getElementById('infoAircraft').textContent = trackedFlight.aircraft_type || '‚Äî';
    } else {
        statusBadge.textContent = 'NOT TRACKING';
        statusBadge.classList.add('inactive');
        statusBadge.classList.remove('tracking');
        statusMessage.textContent = 'Connect Discord and enter callsign to start tracking';
        trackerStatus.classList.remove('active');
        flightInfo.style.display = 'none';
        startBtn.style.display = 'block';
        stopBtn.style.display = 'none';
        trackerForm.style.opacity = '1';
        trackerForm.style.pointerEvents = 'auto';
        document.getElementById('vatsimCallsign').disabled = false;
    }
}

function startLiveUpdates() {
    updateFlightData(); // Initial update
    updateInterval = setInterval(updateFlightData, 15000); // Every 15 seconds
}

function stopLiveUpdates() {
    if (updateInterval) {
        clearInterval(updateInterval);
        updateInterval = null;
    }
}

async function updateFlightData() {
    if (!trackedFlight) return;
    
    try {
        const response = await fetchWithAuth(`${API_URL}/api/vatsim/track/status`);
        
        if (response.ok) {
            const data = await response.json();
            if (data.tracking) {
                const distance = data.tracking.distance_to_destination;
                const speed = data.tracking.current_speed;
                
                // Update distance
                if (distance !== null) {
                    document.getElementById('distanceText').textContent = `${distance}nm`;
                    
                    // Update progress bar (200nm = 0%, 0nm = 100%)
                    const progress = Math.max(0, Math.min(100, ((200 - distance) / 200) * 100));
                    document.getElementById('distanceFill').style.width = `${progress}%`;
                }
                
                // Update speed
                if (speed !== null) {
                    document.getElementById('infoSpeed').textContent = `${speed}kts`;
                }
                
                // Update aircraft type if available
                if (data.tracking.aircraft_type) {
                    document.getElementById('infoAircraft').textContent = data.tracking.aircraft_type;
                }
                
                // Update approach if auto-recommended
                if (data.tracking.recommended_approach) {
                    document.getElementById('infoApproach').textContent = 
                        `${data.tracking.recommended_approach} (Auto)`;
                }
            } else {
                // Tracking ended
                trackedFlight = null;
                updateTrackerUI(false);
                stopLiveUpdates();
                showTrackerMessage('info', 'Tracking ended - Flight completed or disconnected from VATSIM');
            }
        }
    } catch (error) {
        console.error('Error updating flight data:', error);
    }
}

function showTrackerMessage(type, message) {
    const container = document.getElementById('trackerMessage');
    
    const classMap = {
        'error': 'error-message',
        'success': 'success-message',
        'info': 'info-message',
        'loading': 'info-message'
    };
    
    const icon = type === 'loading' ? '<span class="loading-spinner"></span>' : '';
    
    container.innerHTML = `<div class="${classMap[type]}">${icon}${message}</div>`;
    
    if (type !== 'loading') {
        setTimeout(() => {
            container.innerHTML = '';
        }, 5000);
    }
}

const originalCheckAuthStatusVatsim = checkAuthStatus;
if (typeof checkAuthStatus !== 'undefined') {
    checkAuthStatus = async function() {
        await originalCheckAuthStatusVatsim();
        checkTrackingRequirements();
    };
}
</script>
</body>
</html>



